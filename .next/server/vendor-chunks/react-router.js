"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-router";
exports.ids = ["vendor-chunks/react-router"];
exports.modules = {

/***/ "(rsc)/../../node_modules/react-router/index.js":
/*!************************************************!*\
  !*** ../../node_modules/react-router/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MemoryRouter: () => (/* binding */ MemoryRouter),\n/* harmony export */   Navigate: () => (/* binding */ Navigate),\n/* harmony export */   NavigationType: () => (/* reexport safe */ history__WEBPACK_IMPORTED_MODULE_0__.Action),\n/* harmony export */   Outlet: () => (/* binding */ Outlet),\n/* harmony export */   Route: () => (/* binding */ Route),\n/* harmony export */   Router: () => (/* binding */ Router),\n/* harmony export */   Routes: () => (/* binding */ Routes),\n/* harmony export */   UNSAFE_LocationContext: () => (/* binding */ LocationContext),\n/* harmony export */   UNSAFE_NavigationContext: () => (/* binding */ NavigationContext),\n/* harmony export */   UNSAFE_RouteContext: () => (/* binding */ RouteContext),\n/* harmony export */   createPath: () => (/* reexport safe */ history__WEBPACK_IMPORTED_MODULE_0__.createPath),\n/* harmony export */   createRoutesFromChildren: () => (/* binding */ createRoutesFromChildren),\n/* harmony export */   generatePath: () => (/* binding */ generatePath),\n/* harmony export */   matchPath: () => (/* binding */ matchPath),\n/* harmony export */   matchRoutes: () => (/* binding */ matchRoutes),\n/* harmony export */   parsePath: () => (/* reexport safe */ history__WEBPACK_IMPORTED_MODULE_0__.parsePath),\n/* harmony export */   renderMatches: () => (/* binding */ renderMatches),\n/* harmony export */   resolvePath: () => (/* binding */ resolvePath),\n/* harmony export */   useHref: () => (/* binding */ useHref),\n/* harmony export */   useInRouterContext: () => (/* binding */ useInRouterContext),\n/* harmony export */   useLocation: () => (/* binding */ useLocation),\n/* harmony export */   useMatch: () => (/* binding */ useMatch),\n/* harmony export */   useNavigate: () => (/* binding */ useNavigate),\n/* harmony export */   useNavigationType: () => (/* binding */ useNavigationType),\n/* harmony export */   useOutlet: () => (/* binding */ useOutlet),\n/* harmony export */   useOutletContext: () => (/* binding */ useOutletContext),\n/* harmony export */   useParams: () => (/* binding */ useParams),\n/* harmony export */   useResolvedPath: () => (/* binding */ useResolvedPath),\n/* harmony export */   useRoutes: () => (/* binding */ useRoutes)\n/* harmony export */ });\n/* harmony import */ var history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! history */ \"(rsc)/../../node_modules/history/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/**\n * React Router v6.3.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ \n\n\nconst NavigationContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nif (true) {\n    NavigationContext.displayName = \"Navigation\";\n}\nconst LocationContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nif (true) {\n    LocationContext.displayName = \"Location\";\n}\nconst RouteContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    outlet: null,\n    matches: []\n});\nif (true) {\n    RouteContext.displayName = \"Route\";\n}\nfunction invariant(cond, message) {\n    if (!cond) throw new Error(message);\n}\nfunction warning(cond, message) {\n    if (!cond) {\n        // eslint-disable-next-line no-console\n        if (typeof console !== \"undefined\") console.warn(message);\n        try {\n            // Welcome to debugging React Router!\n            //\n            // This error is thrown as a convenience so you can more easily\n            // find the source for a warning that appears in the console by\n            // enabling \"pause on exceptions\" in your JavaScript debugger.\n            throw new Error(message); // eslint-disable-next-line no-empty\n        } catch (e) {}\n    }\n}\nconst alreadyWarned = {};\nfunction warningOnce(key, cond, message) {\n    if (!cond && !alreadyWarned[key]) {\n        alreadyWarned[key] = true;\n         true ? warning(false, message) : 0;\n    }\n}\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/docs/en/v6/api#generatepath\n */ function generatePath(path, params) {\n    if (params === void 0) {\n        params = {};\n    }\n    return path.replace(/:(\\w+)/g, (_, key)=>{\n        !(params[key] != null) ?  true ? invariant(false, 'Missing \":' + key + '\" param') : 0 : void 0;\n        return params[key];\n    }).replace(/\\/*\\*$/, (_)=>params[\"*\"] == null ? \"\" : params[\"*\"].replace(/^\\/*/, \"/\"));\n}\n/**\n * A RouteMatch contains info about how a route matched a URL.\n */ /**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/docs/en/v6/api#matchroutes\n */ function matchRoutes(routes, locationArg, basename) {\n    if (basename === void 0) {\n        basename = \"/\";\n    }\n    let location = typeof locationArg === \"string\" ? (0,history__WEBPACK_IMPORTED_MODULE_0__.parsePath)(locationArg) : locationArg;\n    let pathname = stripBasename(location.pathname || \"/\", basename);\n    if (pathname == null) {\n        return null;\n    }\n    let branches = flattenRoutes(routes);\n    rankRouteBranches(branches);\n    let matches = null;\n    for(let i = 0; matches == null && i < branches.length; ++i){\n        matches = matchRouteBranch(branches[i], pathname);\n    }\n    return matches;\n}\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\n    if (branches === void 0) {\n        branches = [];\n    }\n    if (parentsMeta === void 0) {\n        parentsMeta = [];\n    }\n    if (parentPath === void 0) {\n        parentPath = \"\";\n    }\n    routes.forEach((route, index)=>{\n        let meta = {\n            relativePath: route.path || \"\",\n            caseSensitive: route.caseSensitive === true,\n            childrenIndex: index,\n            route\n        };\n        if (meta.relativePath.startsWith(\"/\")) {\n            !meta.relativePath.startsWith(parentPath) ?  true ? invariant(false, 'Absolute route path \"' + meta.relativePath + '\" nested under path ' + ('\"' + parentPath + '\" is not valid. An absolute child route path ') + \"must start with the combined path of all its parent routes.\") : 0 : void 0;\n            meta.relativePath = meta.relativePath.slice(parentPath.length);\n        }\n        let path = joinPaths([\n            parentPath,\n            meta.relativePath\n        ]);\n        let routesMeta = parentsMeta.concat(meta); // Add the children before adding this route to the array so we traverse the\n        // route tree depth-first and child routes appear before their parents in\n        // the \"flattened\" version.\n        if (route.children && route.children.length > 0) {\n            !(route.index !== true) ?  true ? invariant(false, \"Index routes must not have child routes. Please remove \" + ('all child routes from route path \"' + path + '\".')) : 0 : void 0;\n            flattenRoutes(route.children, branches, routesMeta, path);\n        } // Routes without a path shouldn't ever match by themselves unless they are\n        // index routes, so don't add them to the list of possible branches.\n        if (route.path == null && !route.index) {\n            return;\n        }\n        branches.push({\n            path,\n            score: computeScore(path, route.index),\n            routesMeta\n        });\n    });\n    return branches;\n}\nfunction rankRouteBranches(branches) {\n    branches.sort((a, b)=>a.score !== b.score ? b.score - a.score // Higher score first\n         : compareIndexes(a.routesMeta.map((meta)=>meta.childrenIndex), b.routesMeta.map((meta)=>meta.childrenIndex)));\n}\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = (s)=>s === \"*\";\nfunction computeScore(path, index) {\n    let segments = path.split(\"/\");\n    let initialScore = segments.length;\n    if (segments.some(isSplat)) {\n        initialScore += splatPenalty;\n    }\n    if (index) {\n        initialScore += indexRouteValue;\n    }\n    return segments.filter((s)=>!isSplat(s)).reduce((score, segment)=>score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue), initialScore);\n}\nfunction compareIndexes(a, b) {\n    let siblings = a.length === b.length && a.slice(0, -1).every((n, i)=>n === b[i]);\n    return siblings ? // first. This allows people to have fine-grained control over the matching\n    // behavior by simply putting routes with identical paths in the order they\n    // want them tried.\n    a[a.length - 1] - b[b.length - 1] : // so they sort equally.\n    0;\n}\nfunction matchRouteBranch(branch, pathname) {\n    let { routesMeta } = branch;\n    let matchedParams = {};\n    let matchedPathname = \"/\";\n    let matches = [];\n    for(let i = 0; i < routesMeta.length; ++i){\n        let meta = routesMeta[i];\n        let end = i === routesMeta.length - 1;\n        let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n        let match = matchPath({\n            path: meta.relativePath,\n            caseSensitive: meta.caseSensitive,\n            end\n        }, remainingPathname);\n        if (!match) return null;\n        Object.assign(matchedParams, match.params);\n        let route = meta.route;\n        matches.push({\n            params: matchedParams,\n            pathname: joinPaths([\n                matchedPathname,\n                match.pathname\n            ]),\n            pathnameBase: normalizePathname(joinPaths([\n                matchedPathname,\n                match.pathnameBase\n            ])),\n            route\n        });\n        if (match.pathnameBase !== \"/\") {\n            matchedPathname = joinPaths([\n                matchedPathname,\n                match.pathnameBase\n            ]);\n        }\n    }\n    return matches;\n}\n/**\n * A PathPattern is used to match on some portion of a URL pathname.\n */ /**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/docs/en/v6/api#matchpath\n */ function matchPath(pattern, pathname) {\n    if (typeof pattern === \"string\") {\n        pattern = {\n            path: pattern,\n            caseSensitive: false,\n            end: true\n        };\n    }\n    let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\n    let match = pathname.match(matcher);\n    if (!match) return null;\n    let matchedPathname = match[0];\n    let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n    let captureGroups = match.slice(1);\n    let params = paramNames.reduce((memo, paramName, index)=>{\n        // We need to compute the pathnameBase here using the raw splat value\n        // instead of using params[\"*\"] later because it will be decoded then\n        if (paramName === \"*\") {\n            let splatValue = captureGroups[index] || \"\";\n            pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\n        }\n        memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || \"\", paramName);\n        return memo;\n    }, {});\n    return {\n        params,\n        pathname: matchedPathname,\n        pathnameBase,\n        pattern\n    };\n}\nfunction compilePath(path, caseSensitive, end) {\n    if (caseSensitive === void 0) {\n        caseSensitive = false;\n    }\n    if (end === void 0) {\n        end = true;\n    }\n     true ? warning(path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"), 'Route path \"' + path + '\" will be treated as if it were ' + ('\"' + path.replace(/\\*$/, \"/*\") + '\" because the `*` character must ') + \"always follow a `/` in the pattern. To get rid of this warning, \" + ('please change the route path to \"' + path.replace(/\\*$/, \"/*\") + '\".')) : 0;\n    let paramNames = [];\n    let regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n    .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n    .replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n    .replace(/:(\\w+)/g, (_, paramName)=>{\n        paramNames.push(paramName);\n        return \"([^\\\\/]+)\";\n    });\n    if (path.endsWith(\"*\")) {\n        paramNames.push(\"*\");\n        regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" // Already matched the initial /, just match the rest\n         : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n    } else {\n        regexpSource += end ? \"\\\\/*$\" // When matching to the end, ignore trailing slashes\n         : // parent routes to matching only their own words and nothing more, e.g. parent\n        // route \"/home\" should not match \"/home2\".\n        // Additionally, allow paths starting with `.`, `-`, `~`, and url-encoded entities,\n        // but do not consume the character in the matched path so they can match against\n        // nested paths.\n        \"(?:(?=[.~-]|%[0-9A-F]{2})|\\\\b|\\\\/|$)\";\n    }\n    let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n    return [\n        matcher,\n        paramNames\n    ];\n}\nfunction safelyDecodeURIComponent(value, paramName) {\n    try {\n        return decodeURIComponent(value);\n    } catch (error) {\n         true ? warning(false, 'The value for the URL param \"' + paramName + '\" will not be decoded because' + (' the string \"' + value + '\" is a malformed URL segment. This is probably') + (\" due to a bad percent encoding (\" + error + \").\")) : 0;\n        return value;\n    }\n}\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/docs/en/v6/api#resolvepath\n */ function resolvePath(to, fromPathname) {\n    if (fromPathname === void 0) {\n        fromPathname = \"/\";\n    }\n    let { pathname: toPathname, search = \"\", hash = \"\" } = typeof to === \"string\" ? (0,history__WEBPACK_IMPORTED_MODULE_0__.parsePath)(to) : to;\n    let pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n    return {\n        pathname,\n        search: normalizeSearch(search),\n        hash: normalizeHash(hash)\n    };\n}\nfunction resolvePathname(relativePath, fromPathname) {\n    let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n    let relativeSegments = relativePath.split(\"/\");\n    relativeSegments.forEach((segment)=>{\n        if (segment === \"..\") {\n            // Keep the root \"\" segment so the pathname starts at /\n            if (segments.length > 1) segments.pop();\n        } else if (segment !== \".\") {\n            segments.push(segment);\n        }\n    });\n    return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\nfunction resolveTo(toArg, routePathnames, locationPathname) {\n    let to = typeof toArg === \"string\" ? (0,history__WEBPACK_IMPORTED_MODULE_0__.parsePath)(toArg) : toArg;\n    let toPathname = toArg === \"\" || to.pathname === \"\" ? \"/\" : to.pathname; // If a pathname is explicitly provided in `to`, it should be relative to the\n    // route context. This is explained in `Note on `<Link to>` values` in our\n    // migration guide from v5 as a means of disambiguation between `to` values\n    // that begin with `/` and those that do not. However, this is problematic for\n    // `to` values that do not provide a pathname. `to` can simply be a search or\n    // hash string, in which case we should assume that the navigation is relative\n    // to the current location's pathname and *not* the route pathname.\n    let from;\n    if (toPathname == null) {\n        from = locationPathname;\n    } else {\n        let routePathnameIndex = routePathnames.length - 1;\n        if (toPathname.startsWith(\"..\")) {\n            let toSegments = toPathname.split(\"/\"); // Each leading .. segment means \"go up one route\" instead of \"go up one\n            // URL segment\".  This is a key difference from how <a href> works and a\n            // major reason we call this a \"to\" value instead of a \"href\".\n            while(toSegments[0] === \"..\"){\n                toSegments.shift();\n                routePathnameIndex -= 1;\n            }\n            to.pathname = toSegments.join(\"/\");\n        } // If there are more \"..\" segments than parent routes, resolve relative to\n        // the root / URL.\n        from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n    }\n    let path = resolvePath(to, from); // Ensure the pathname has a trailing slash if the original to value had one.\n    if (toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\") && !path.pathname.endsWith(\"/\")) {\n        path.pathname += \"/\";\n    }\n    return path;\n}\nfunction getToPathname(to) {\n    // Empty strings should be treated the same as / paths\n    return to === \"\" || to.pathname === \"\" ? \"/\" : typeof to === \"string\" ? (0,history__WEBPACK_IMPORTED_MODULE_0__.parsePath)(to).pathname : to.pathname;\n}\nfunction stripBasename(pathname, basename) {\n    if (basename === \"/\") return pathname;\n    if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n        return null;\n    }\n    let nextChar = pathname.charAt(basename.length);\n    if (nextChar && nextChar !== \"/\") {\n        // pathname does not start with basename/\n        return null;\n    }\n    return pathname.slice(basename.length) || \"/\";\n}\nconst joinPaths = (paths)=>paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\nconst normalizePathname = (pathname)=>pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\nconst normalizeSearch = (search)=>!search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\nconst normalizeHash = (hash)=>!hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usehref\n */ function useHref(to) {\n    !useInRouterContext() ?  true ? invariant(false, // router loaded. We can help them understand how to avoid that.\n    \"useHref() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let { basename, navigator } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(NavigationContext);\n    let { hash, pathname, search } = useResolvedPath(to);\n    let joinedPathname = pathname;\n    if (basename !== \"/\") {\n        let toPathname = getToPathname(to);\n        let endsWithSlash = toPathname != null && toPathname.endsWith(\"/\");\n        joinedPathname = pathname === \"/\" ? basename + (endsWithSlash ? \"/\" : \"\") : joinPaths([\n            basename,\n            pathname\n        ]);\n    }\n    return navigator.createHref({\n        pathname: joinedPathname,\n        search,\n        hash\n    });\n}\n/**\n * Returns true if this component is a descendant of a <Router>.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useinroutercontext\n */ function useInRouterContext() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LocationContext) != null;\n}\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/docs/en/v6/api#uselocation\n */ function useLocation() {\n    !useInRouterContext() ?  true ? invariant(false, // router loaded. We can help them understand how to avoid that.\n    \"useLocation() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LocationContext).location;\n}\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usenavigationtype\n */ function useNavigationType() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LocationContext).navigationType;\n}\n/**\n * Returns true if the URL for the given \"to\" value matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usematch\n */ function useMatch(pattern) {\n    !useInRouterContext() ?  true ? invariant(false, // router loaded. We can help them understand how to avoid that.\n    \"useMatch() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let { pathname } = useLocation();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>matchPath(pattern, pathname), [\n        pathname,\n        pattern\n    ]);\n}\n/**\n * The interface for the navigate() function returned from useNavigate().\n */ /**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usenavigate\n */ function useNavigate() {\n    !useInRouterContext() ?  true ? invariant(false, // router loaded. We can help them understand how to avoid that.\n    \"useNavigate() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let { basename, navigator } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(NavigationContext);\n    let { matches } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let routePathnamesJson = JSON.stringify(matches.map((match)=>match.pathnameBase));\n    let activeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        activeRef.current = true;\n    });\n    let navigate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(to, options) {\n        if (options === void 0) {\n            options = {};\n        }\n         true ? warning(activeRef.current, \"You should call navigate() in a React.useEffect(), not when \" + \"your component is first rendered.\") : 0;\n        if (!activeRef.current) return;\n        if (typeof to === \"number\") {\n            navigator.go(to);\n            return;\n        }\n        let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname);\n        if (basename !== \"/\") {\n            path.pathname = joinPaths([\n                basename,\n                path.pathname\n            ]);\n        }\n        (!!options.replace ? navigator.replace : navigator.push)(path, options.state);\n    }, [\n        basename,\n        navigator,\n        routePathnamesJson,\n        locationPathname\n    ]);\n    return navigate;\n}\nconst OutletContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/docs/en/v6/api#useoutletcontext\n */ function useOutletContext() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(OutletContext);\n}\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by <Outlet> to render child routes.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useoutlet\n */ function useOutlet(context) {\n    let outlet = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(RouteContext).outlet;\n    if (outlet) {\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(OutletContext.Provider, {\n            value: context\n        }, outlet);\n    }\n    return outlet;\n}\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useparams\n */ function useParams() {\n    let { matches } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(RouteContext);\n    let routeMatch = matches[matches.length - 1];\n    return routeMatch ? routeMatch.params : {};\n}\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useresolvedpath\n */ function useResolvedPath(to) {\n    let { matches } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let routePathnamesJson = JSON.stringify(matches.map((match)=>match.pathnameBase));\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>resolveTo(to, JSON.parse(routePathnamesJson), locationPathname), [\n        to,\n        routePathnamesJson,\n        locationPathname\n    ]);\n}\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useroutes\n */ function useRoutes(routes, locationArg) {\n    !useInRouterContext() ?  true ? invariant(false, // router loaded. We can help them understand how to avoid that.\n    \"useRoutes() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let { matches: parentMatches } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(RouteContext);\n    let routeMatch = parentMatches[parentMatches.length - 1];\n    let parentParams = routeMatch ? routeMatch.params : {};\n    let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n    let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n    let parentRoute = routeMatch && routeMatch.route;\n    if (true) {\n        // You won't get a warning about 2 different <Routes> under a <Route>\n        // without a trailing *, but this is a best-effort warning anyway since we\n        // cannot even give the warning unless they land at the parent route.\n        //\n        // Example:\n        //\n        // <Routes>\n        //   {/* This route path MUST end with /* because otherwise\n        //       it will never match /blog/post/123 */}\n        //   <Route path=\"blog\" element={<Blog />} />\n        //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n        // </Routes>\n        //\n        // function Blog() {\n        //   return (\n        //     <Routes>\n        //       <Route path=\"post/:id\" element={<Post />} />\n        //     </Routes>\n        //   );\n        // }\n        let parentPath = parentRoute && parentRoute.path || \"\";\n        warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes()`) at \" + ('\"' + parentPathname + '\" (under <Route path=\"' + parentPath + '\">) but the ') + 'parent route path has no trailing \"*\". This means if you navigate ' + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + ('Please change the parent <Route path=\"' + parentPath + '\"> to <Route ') + ('path=\"' + (parentPath === \"/\" ? \"*\" : parentPath + \"/*\") + '\">.'));\n    }\n    let locationFromContext = useLocation();\n    let location;\n    if (locationArg) {\n        var _parsedLocationArg$pa;\n        let parsedLocationArg = typeof locationArg === \"string\" ? (0,history__WEBPACK_IMPORTED_MODULE_0__.parsePath)(locationArg) : locationArg;\n        !(parentPathnameBase === \"/\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ?  true ? invariant(false, \"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \" + \"the location pathname must begin with the portion of the URL pathname that was \" + ('matched by all parent routes. The current pathname base is \"' + parentPathnameBase + '\" ') + ('but pathname \"' + parsedLocationArg.pathname + '\" was given in the `location` prop.')) : 0 : void 0;\n        location = parsedLocationArg;\n    } else {\n        location = locationFromContext;\n    }\n    let pathname = location.pathname || \"/\";\n    let remainingPathname = parentPathnameBase === \"/\" ? pathname : pathname.slice(parentPathnameBase.length) || \"/\";\n    let matches = matchRoutes(routes, {\n        pathname: remainingPathname\n    });\n    if (true) {\n         true ? warning(parentRoute || matches != null, 'No routes matched location \"' + location.pathname + location.search + location.hash + '\" ') : 0;\n         true ? warning(matches == null || matches[matches.length - 1].route.element !== undefined, 'Matched leaf route at location \"' + location.pathname + location.search + location.hash + '\" does not have an element. ' + 'This means it will render an <Outlet /> with a null value by default resulting in an \"empty\" page.') : 0;\n    }\n    return _renderMatches(matches && matches.map((match)=>Object.assign({}, match, {\n            params: Object.assign({}, parentParams, match.params),\n            pathname: joinPaths([\n                parentPathnameBase,\n                match.pathname\n            ]),\n            pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : joinPaths([\n                parentPathnameBase,\n                match.pathnameBase\n            ])\n        })), parentMatches);\n}\nfunction _renderMatches(matches, parentMatches) {\n    if (parentMatches === void 0) {\n        parentMatches = [];\n    }\n    if (matches == null) return null;\n    return matches.reduceRight((outlet, match, index)=>{\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(RouteContext.Provider, {\n            children: match.route.element !== undefined ? match.route.element : outlet,\n            value: {\n                outlet,\n                matches: parentMatches.concat(matches.slice(0, index + 1))\n            }\n        });\n    }, null);\n}\n/**\n * A <Router> that stores all entries in memory.\n *\n * @see https://reactrouter.com/docs/en/v6/api#memoryrouter\n */ function MemoryRouter(_ref) {\n    let { basename, children, initialEntries, initialIndex } = _ref;\n    let historyRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    if (historyRef.current == null) {\n        historyRef.current = (0,history__WEBPACK_IMPORTED_MODULE_0__.createMemoryHistory)({\n            initialEntries,\n            initialIndex\n        });\n    }\n    let history = historyRef.current;\n    let [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        action: history.action,\n        location: history.location\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(()=>history.listen(setState), [\n        history\n    ]);\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/docs/en/v6/api#navigate\n */ function Navigate(_ref2) {\n    let { to, replace, state } = _ref2;\n    !useInRouterContext() ?  true ? invariant(false, // the router loaded. We can help them understand how to avoid that.\n    \"<Navigate> may be used only in the context of a <Router> component.\") : 0 : void 0;\n     true ? warning(!(0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(NavigationContext).static, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") : 0;\n    let navigate = useNavigate();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        navigate(to, {\n            replace,\n            state\n        });\n    });\n    return null;\n}\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/docs/en/v6/api#outlet\n */ function Outlet(props) {\n    return useOutlet(props.context);\n}\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/docs/en/v6/api#route\n */ function Route(_props) {\n     true ? invariant(false, \"A <Route> is only ever to be used as the child of <Routes> element, \" + \"never rendered directly. Please wrap your <Route> in a <Routes>.\") : 0;\n}\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\n * router that is more specific to your environment such as a <BrowserRouter>\n * in web browsers or a <StaticRouter> for server rendering.\n *\n * @see https://reactrouter.com/docs/en/v6/api#router\n */ function Router(_ref3) {\n    let { basename: basenameProp = \"/\", children = null, location: locationProp, navigationType = history__WEBPACK_IMPORTED_MODULE_0__.Action.Pop, navigator, static: staticProp = false } = _ref3;\n    !!useInRouterContext() ?  true ? invariant(false, \"You cannot render a <Router> inside another <Router>.\" + \" You should never have more than one in your app.\") : 0 : void 0;\n    let basename = normalizePathname(basenameProp);\n    let navigationContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({\n            basename,\n            navigator,\n            static: staticProp\n        }), [\n        basename,\n        navigator,\n        staticProp\n    ]);\n    if (typeof locationProp === \"string\") {\n        locationProp = (0,history__WEBPACK_IMPORTED_MODULE_0__.parsePath)(locationProp);\n    }\n    let { pathname = \"/\", search = \"\", hash = \"\", state = null, key = \"default\" } = locationProp;\n    let location = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        let trailingPathname = stripBasename(pathname, basename);\n        if (trailingPathname == null) {\n            return null;\n        }\n        return {\n            pathname: trailingPathname,\n            search,\n            hash,\n            state,\n            key\n        };\n    }, [\n        basename,\n        pathname,\n        search,\n        hash,\n        state,\n        key\n    ]);\n     true ? warning(location != null, '<Router basename=\"' + basename + '\"> is not able to match the URL ' + ('\"' + pathname + search + hash + '\" because it does not start with the ') + \"basename, so the <Router> won't render anything.\") : 0;\n    if (location == null) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(NavigationContext.Provider, {\n        value: navigationContext\n    }, /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(LocationContext.Provider, {\n        children: children,\n        value: {\n            location,\n            navigationType\n        }\n    }));\n}\n/**\n * A container for a nested tree of <Route> elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#routes\n */ function Routes(_ref4) {\n    let { children, location } = _ref4;\n    return useRoutes(createRoutesFromChildren(children), location);\n} ///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/docs/en/v6/api#createroutesfromchildren\n */ function createRoutesFromChildren(children) {\n    let routes = [];\n    react__WEBPACK_IMPORTED_MODULE_1__.Children.forEach(children, (element)=>{\n        if (!/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.isValidElement)(element)) {\n            // Ignore non-elements. This allows people to more easily inline\n            // conditionals in their route config.\n            return;\n        }\n        if (element.type === react__WEBPACK_IMPORTED_MODULE_1__.Fragment) {\n            // Transparently support React.Fragment and its children.\n            routes.push.apply(routes, createRoutesFromChildren(element.props.children));\n            return;\n        }\n        !(element.type === Route) ?  true ? invariant(false, \"[\" + (typeof element.type === \"string\" ? element.type : element.type.name) + \"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\") : 0 : void 0;\n        let route = {\n            caseSensitive: element.props.caseSensitive,\n            element: element.props.element,\n            index: element.props.index,\n            path: element.props.path\n        };\n        if (element.props.children) {\n            route.children = createRoutesFromChildren(element.props.children);\n        }\n        routes.push(route);\n    });\n    return routes;\n}\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */ function renderMatches(matches) {\n    return _renderMatches(matches);\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Q0FTQyxHQUNnRTtBQUNTO0FBQytGO0FBRXpLLE1BQU1pQixvQkFBb0IsV0FBVyxHQUFFWixvREFBYUEsQ0FBQztBQUVyRCxJQUFJYSxJQUFxQyxFQUFFO0lBQ3pDRCxrQkFBa0JFLFdBQVcsR0FBRztBQUNsQztBQUVBLE1BQU1DLGtCQUFrQixXQUFXLEdBQUVmLG9EQUFhQSxDQUFDO0FBRW5ELElBQUlhLElBQXFDLEVBQUU7SUFDekNFLGdCQUFnQkQsV0FBVyxHQUFHO0FBQ2hDO0FBRUEsTUFBTUUsZUFBZSxXQUFXLEdBQUVoQixvREFBYUEsQ0FBQztJQUM5Q2lCLFFBQVE7SUFDUkMsU0FBUyxFQUFFO0FBQ2I7QUFFQSxJQUFJTCxJQUFxQyxFQUFFO0lBQ3pDRyxhQUFhRixXQUFXLEdBQUc7QUFDN0I7QUFFQSxTQUFTSyxVQUFVQyxJQUFJLEVBQUVDLE9BQU87SUFDOUIsSUFBSSxDQUFDRCxNQUFNLE1BQU0sSUFBSUUsTUFBTUQ7QUFDN0I7QUFDQSxTQUFTRSxRQUFRSCxJQUFJLEVBQUVDLE9BQU87SUFDNUIsSUFBSSxDQUFDRCxNQUFNO1FBQ1Qsc0NBQXNDO1FBQ3RDLElBQUksT0FBT0ksWUFBWSxhQUFhQSxRQUFRQyxJQUFJLENBQUNKO1FBRWpELElBQUk7WUFDRixxQ0FBcUM7WUFDckMsRUFBRTtZQUNGLCtEQUErRDtZQUMvRCwrREFBK0Q7WUFDL0QsOERBQThEO1lBQzlELE1BQU0sSUFBSUMsTUFBTUQsVUFBVSxvQ0FBb0M7UUFDaEUsRUFBRSxPQUFPSyxHQUFHLENBQUM7SUFDZjtBQUNGO0FBQ0EsTUFBTUMsZ0JBQWdCLENBQUM7QUFDdkIsU0FBU0MsWUFBWUMsR0FBRyxFQUFFVCxJQUFJLEVBQUVDLE9BQU87SUFDckMsSUFBSSxDQUFDRCxRQUFRLENBQUNPLGFB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cURBQWNBLENBQUMwSyxVQUFVO1lBQzFDLGdFQUFnRTtZQUNoRSxzQ0FBc0M7WUFDdEM7UUFDRjtRQUVBLElBQUlBLFFBQVE4QixJQUFJLEtBQUt2TSwyQ0FBUUEsRUFBRTtZQUM3Qix5REFBeUQ7WUFDekR5QixPQUFPMkIsSUFBSSxDQUFDb0osS0FBSyxDQUFDL0ssUUFBUTZLLHlCQUF5QjdCLFFBQVFpQixLQUFLLENBQUN2SSxRQUFRO1lBQ3pFO1FBQ0Y7UUFFQSxDQUFFc0gsQ0FBQUEsUUFBUThCLElBQUksS0FBS1osS0FBSSxJQUFLekwsS0FBcUMsR0FBR00sVUFBVSxPQUFPLE1BQU8sUUFBT2lLLFFBQVE4QixJQUFJLEtBQUssV0FBVzlCLFFBQVE4QixJQUFJLEdBQUc5QixRQUFROEIsSUFBSSxDQUFDRSxJQUFJLElBQUksNEdBQTRHak0sQ0FBZ0IsR0FBRyxLQUFLO1FBQ3ZTLElBQUlnQyxRQUFRO1lBQ1ZJLGVBQWU2SCxRQUFRaUIsS0FBSyxDQUFDOUksYUFBYTtZQUMxQzZILFNBQVNBLFFBQVFpQixLQUFLLENBQUNqQixPQUFPO1lBQzlCaEksT0FBT2dJLFFBQVFpQixLQUFLLENBQUNqSixLQUFLO1lBQzFCckIsTUFBTXFKLFFBQVFpQixLQUFLLENBQUN0SyxJQUFJO1FBQzFCO1FBRUEsSUFBSXFKLFFBQVFpQixLQUFLLENBQUN2SSxRQUFRLEVBQUU7WUFDMUJYLE1BQU1XLFFBQVEsR0FBR21KLHlCQUF5QjdCLFFBQVFpQixLQUFLLENBQUN2SSxRQUFRO1FBQ2xFO1FBRUExQixPQUFPMkIsSUFBSSxDQUFDWjtJQUNkO0lBQ0EsT0FBT2Y7QUFDVDtBQUNBOztDQUVDLEdBRUQsU0FBU2lMLGNBQWNuTSxPQUFPO0lBQzVCLE9BQU9tSyxlQUFlbks7QUFDeEI7QUFFb2IsQ0FDcGIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVhcm5fbmV4dGpzMTQvLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9pbmRleC5qcz83ZmQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVhY3QgUm91dGVyIHY2LjMuMFxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBwYXJzZVBhdGgsIGNyZWF0ZU1lbW9yeUhpc3RvcnksIEFjdGlvbiB9IGZyb20gJ2hpc3RvcnknO1xuZXhwb3J0IHsgQWN0aW9uIGFzIE5hdmlnYXRpb25UeXBlLCBjcmVhdGVQYXRoLCBwYXJzZVBhdGggfSBmcm9tICdoaXN0b3J5JztcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZU1lbW8sIHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgY3JlYXRlRWxlbWVudCwgdXNlU3RhdGUsIHVzZUxheW91dEVmZmVjdCwgQ2hpbGRyZW4sIGlzVmFsaWRFbGVtZW50LCBGcmFnbWVudCB9IGZyb20gJ3JlYWN0JztcblxuY29uc3QgTmF2aWdhdGlvbkNvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dChudWxsKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBOYXZpZ2F0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiTmF2aWdhdGlvblwiO1xufVxuXG5jb25zdCBMb2NhdGlvbkNvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dChudWxsKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBMb2NhdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkxvY2F0aW9uXCI7XG59XG5cbmNvbnN0IFJvdXRlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KHtcbiAgb3V0bGV0OiBudWxsLFxuICBtYXRjaGVzOiBbXVxufSk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgUm91dGVDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJSb3V0ZVwiO1xufVxuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZCwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmQpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cbmZ1bmN0aW9uIHdhcm5pbmcoY29uZCwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IFJvdXRlciFcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGVycm9yIGlzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHlvdSBjYW4gbW9yZSBlYXNpbHlcbiAgICAgIC8vIGZpbmQgdGhlIHNvdXJjZSBmb3IgYSB3YXJuaW5nIHRoYXQgYXBwZWFycyBpbiB0aGUgY29uc29sZSBieVxuICAgICAgLy8gZW5hYmxpbmcgXCJwYXVzZSBvbiBleGNlcHRpb25zXCIgaW4geW91ciBKYXZhU2NyaXB0IGRlYnVnZ2VyLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG59XG5jb25zdCBhbHJlYWR5V2FybmVkID0ge307XG5mdW5jdGlvbiB3YXJuaW5nT25jZShrZXksIGNvbmQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kICYmICFhbHJlYWR5V2FybmVkW2tleV0pIHtcbiAgICBhbHJlYWR5V2FybmVkW2tleV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIG1lc3NhZ2UpIDogdm9pZCAwO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHBhdGggd2l0aCBwYXJhbXMgaW50ZXJwb2xhdGVkLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjZ2VuZXJhdGVwYXRoXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlUGF0aChwYXRoLCBwYXJhbXMpIHtcbiAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7XG4gICAgcGFyYW1zID0ge307XG4gIH1cblxuICByZXR1cm4gcGF0aC5yZXBsYWNlKC86KFxcdyspL2csIChfLCBrZXkpID0+IHtcbiAgICAhKHBhcmFtc1trZXldICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIk1pc3NpbmcgXFxcIjpcIiArIGtleSArIFwiXFxcIiBwYXJhbVwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIHBhcmFtc1trZXldO1xuICB9KS5yZXBsYWNlKC9cXC8qXFwqJC8sIF8gPT4gcGFyYW1zW1wiKlwiXSA9PSBudWxsID8gXCJcIiA6IHBhcmFtc1tcIipcIl0ucmVwbGFjZSgvXlxcLyovLCBcIi9cIikpO1xufVxuLyoqXG4gKiBBIFJvdXRlTWF0Y2ggY29udGFpbnMgaW5mbyBhYm91dCBob3cgYSByb3V0ZSBtYXRjaGVkIGEgVVJMLlxuICovXG5cbi8qKlxuICogTWF0Y2hlcyB0aGUgZ2l2ZW4gcm91dGVzIHRvIGEgbG9jYXRpb24gYW5kIHJldHVybnMgdGhlIG1hdGNoIGRhdGEuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNtYXRjaHJvdXRlc1xuICovXG5mdW5jdGlvbiBtYXRjaFJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uQXJnLCBiYXNlbmFtZSkge1xuICBpZiAoYmFzZW5hbWUgPT09IHZvaWQgMCkge1xuICAgIGJhc2VuYW1lID0gXCIvXCI7XG4gIH1cblxuICBsZXQgbG9jYXRpb24gPSB0eXBlb2YgbG9jYXRpb25BcmcgPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgobG9jYXRpb25BcmcpIDogbG9jYXRpb25Bcmc7XG4gIGxldCBwYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUobG9jYXRpb24ucGF0aG5hbWUgfHwgXCIvXCIsIGJhc2VuYW1lKTtcblxuICBpZiAocGF0aG5hbWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGV0IGJyYW5jaGVzID0gZmxhdHRlblJvdXRlcyhyb3V0ZXMpO1xuICByYW5rUm91dGVCcmFuY2hlcyhicmFuY2hlcyk7XG4gIGxldCBtYXRjaGVzID0gbnVsbDtcblxuICBmb3IgKGxldCBpID0gMDsgbWF0Y2hlcyA9PSBudWxsICYmIGkgPCBicmFuY2hlcy5sZW5ndGg7ICsraSkge1xuICAgIG1hdGNoZXMgPSBtYXRjaFJvdXRlQnJhbmNoKGJyYW5jaGVzW2ldLCBwYXRobmFtZSk7XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcztcbn1cblxuZnVuY3Rpb24gZmxhdHRlblJvdXRlcyhyb3V0ZXMsIGJyYW5jaGVzLCBwYXJlbnRzTWV0YSwgcGFyZW50UGF0aCkge1xuICBpZiAoYnJhbmNoZXMgPT09IHZvaWQgMCkge1xuICAgIGJyYW5jaGVzID0gW107XG4gIH1cblxuICBpZiAocGFyZW50c01ldGEgPT09IHZvaWQgMCkge1xuICAgIHBhcmVudHNNZXRhID0gW107XG4gIH1cblxuICBpZiAocGFyZW50UGF0aCA9PT0gdm9pZCAwKSB7XG4gICAgcGFyZW50UGF0aCA9IFwiXCI7XG4gIH1cblxuICByb3V0ZXMuZm9yRWFjaCgocm91dGUsIGluZGV4KSA9PiB7XG4gICAgbGV0IG1ldGEgPSB7XG4gICAgICByZWxhdGl2ZVBhdGg6IHJvdXRlLnBhdGggfHwgXCJcIixcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHJvdXRlLmNhc2VTZW5zaXRpdmUgPT09IHRydWUsXG4gICAgICBjaGlsZHJlbkluZGV4OiBpbmRleCxcbiAgICAgIHJvdXRlXG4gICAgfTtcblxuICAgIGlmIChtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgIW1ldGEucmVsYXRpdmVQYXRoLnN0YXJ0c1dpdGgocGFyZW50UGF0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiQWJzb2x1dGUgcm91dGUgcGF0aCBcXFwiXCIgKyBtZXRhLnJlbGF0aXZlUGF0aCArIFwiXFxcIiBuZXN0ZWQgdW5kZXIgcGF0aCBcIiArIChcIlxcXCJcIiArIHBhcmVudFBhdGggKyBcIlxcXCIgaXMgbm90IHZhbGlkLiBBbiBhYnNvbHV0ZSBjaGlsZCByb3V0ZSBwYXRoIFwiKSArIFwibXVzdCBzdGFydCB3aXRoIHRoZSBjb21iaW5lZCBwYXRoIG9mIGFsbCBpdHMgcGFyZW50IHJvdXRlcy5cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgbWV0YS5yZWxhdGl2ZVBhdGggPSBtZXRhLnJlbGF0aXZlUGF0aC5zbGljZShwYXJlbnRQYXRoLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgbGV0IHBhdGggPSBqb2luUGF0aHMoW3BhcmVudFBhdGgsIG1ldGEucmVsYXRpdmVQYXRoXSk7XG4gICAgbGV0IHJvdXRlc01ldGEgPSBwYXJlbnRzTWV0YS5jb25jYXQobWV0YSk7IC8vIEFkZCB0aGUgY2hpbGRyZW4gYmVmb3JlIGFkZGluZyB0aGlzIHJvdXRlIHRvIHRoZSBhcnJheSBzbyB3ZSB0cmF2ZXJzZSB0aGVcbiAgICAvLyByb3V0ZSB0cmVlIGRlcHRoLWZpcnN0IGFuZCBjaGlsZCByb3V0ZXMgYXBwZWFyIGJlZm9yZSB0aGVpciBwYXJlbnRzIGluXG4gICAgLy8gdGhlIFwiZmxhdHRlbmVkXCIgdmVyc2lvbi5cblxuICAgIGlmIChyb3V0ZS5jaGlsZHJlbiAmJiByb3V0ZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAhKHJvdXRlLmluZGV4ICE9PSB0cnVlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJJbmRleCByb3V0ZXMgbXVzdCBub3QgaGF2ZSBjaGlsZCByb3V0ZXMuIFBsZWFzZSByZW1vdmUgXCIgKyAoXCJhbGwgY2hpbGQgcm91dGVzIGZyb20gcm91dGUgcGF0aCBcXFwiXCIgKyBwYXRoICsgXCJcXFwiLlwiKSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgZmxhdHRlblJvdXRlcyhyb3V0ZS5jaGlsZHJlbiwgYnJhbmNoZXMsIHJvdXRlc01ldGEsIHBhdGgpO1xuICAgIH0gLy8gUm91dGVzIHdpdGhvdXQgYSBwYXRoIHNob3VsZG4ndCBldmVyIG1hdGNoIGJ5IHRoZW1zZWx2ZXMgdW5sZXNzIHRoZXkgYXJlXG4gICAgLy8gaW5kZXggcm91dGVzLCBzbyBkb24ndCBhZGQgdGhlbSB0byB0aGUgbGlzdCBvZiBwb3NzaWJsZSBicmFuY2hlcy5cblxuXG4gICAgaWYgKHJvdXRlLnBhdGggPT0gbnVsbCAmJiAhcm91dGUuaW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBicmFuY2hlcy5wdXNoKHtcbiAgICAgIHBhdGgsXG4gICAgICBzY29yZTogY29tcHV0ZVNjb3JlKHBhdGgsIHJvdXRlLmluZGV4KSxcbiAgICAgIHJvdXRlc01ldGFcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBicmFuY2hlcztcbn1cblxuZnVuY3Rpb24gcmFua1JvdXRlQnJhbmNoZXMoYnJhbmNoZXMpIHtcbiAgYnJhbmNoZXMuc29ydCgoYSwgYikgPT4gYS5zY29yZSAhPT0gYi5zY29yZSA/IGIuc2NvcmUgLSBhLnNjb3JlIC8vIEhpZ2hlciBzY29yZSBmaXJzdFxuICA6IGNvbXBhcmVJbmRleGVzKGEucm91dGVzTWV0YS5tYXAobWV0YSA9PiBtZXRhLmNoaWxkcmVuSW5kZXgpLCBiLnJvdXRlc01ldGEubWFwKG1ldGEgPT4gbWV0YS5jaGlsZHJlbkluZGV4KSkpO1xufVxuXG5jb25zdCBwYXJhbVJlID0gL146XFx3KyQvO1xuY29uc3QgZHluYW1pY1NlZ21lbnRWYWx1ZSA9IDM7XG5jb25zdCBpbmRleFJvdXRlVmFsdWUgPSAyO1xuY29uc3QgZW1wdHlTZWdtZW50VmFsdWUgPSAxO1xuY29uc3Qgc3RhdGljU2VnbWVudFZhbHVlID0gMTA7XG5jb25zdCBzcGxhdFBlbmFsdHkgPSAtMjtcblxuY29uc3QgaXNTcGxhdCA9IHMgPT4gcyA9PT0gXCIqXCI7XG5cbmZ1bmN0aW9uIGNvbXB1dGVTY29yZShwYXRoLCBpbmRleCkge1xuICBsZXQgc2VnbWVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgbGV0IGluaXRpYWxTY29yZSA9IHNlZ21lbnRzLmxlbmd0aDtcblxuICBpZiAoc2VnbWVudHMuc29tZShpc1NwbGF0KSkge1xuICAgIGluaXRpYWxTY29yZSArPSBzcGxhdFBlbmFsdHk7XG4gIH1cblxuICBpZiAoaW5kZXgpIHtcbiAgICBpbml0aWFsU2NvcmUgKz0gaW5kZXhSb3V0ZVZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHNlZ21lbnRzLmZpbHRlcihzID0+ICFpc1NwbGF0KHMpKS5yZWR1Y2UoKHNjb3JlLCBzZWdtZW50KSA9PiBzY29yZSArIChwYXJhbVJlLnRlc3Qoc2VnbWVudCkgPyBkeW5hbWljU2VnbWVudFZhbHVlIDogc2VnbWVudCA9PT0gXCJcIiA/IGVtcHR5U2VnbWVudFZhbHVlIDogc3RhdGljU2VnbWVudFZhbHVlKSwgaW5pdGlhbFNjb3JlKTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZUluZGV4ZXMoYSwgYikge1xuICBsZXQgc2libGluZ3MgPSBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5zbGljZSgwLCAtMSkuZXZlcnkoKG4sIGkpID0+IG4gPT09IGJbaV0pO1xuICByZXR1cm4gc2libGluZ3MgPyAvLyBJZiB0d28gcm91dGVzIGFyZSBzaWJsaW5ncywgd2Ugc2hvdWxkIHRyeSB0byBtYXRjaCB0aGUgZWFybGllciBzaWJsaW5nXG4gIC8vIGZpcnN0LiBUaGlzIGFsbG93cyBwZW9wbGUgdG8gaGF2ZSBmaW5lLWdyYWluZWQgY29udHJvbCBvdmVyIHRoZSBtYXRjaGluZ1xuICAvLyBiZWhhdmlvciBieSBzaW1wbHkgcHV0dGluZyByb3V0ZXMgd2l0aCBpZGVudGljYWwgcGF0aHMgaW4gdGhlIG9yZGVyIHRoZXlcbiAgLy8gd2FudCB0aGVtIHRyaWVkLlxuICBhW2EubGVuZ3RoIC0gMV0gLSBiW2IubGVuZ3RoIC0gMV0gOiAvLyBPdGhlcndpc2UsIGl0IGRvZXNuJ3QgcmVhbGx5IG1ha2Ugc2Vuc2UgdG8gcmFuayBub24tc2libGluZ3MgYnkgaW5kZXgsXG4gIC8vIHNvIHRoZXkgc29ydCBlcXVhbGx5LlxuICAwO1xufVxuXG5mdW5jdGlvbiBtYXRjaFJvdXRlQnJhbmNoKGJyYW5jaCwgcGF0aG5hbWUpIHtcbiAgbGV0IHtcbiAgICByb3V0ZXNNZXRhXG4gIH0gPSBicmFuY2g7XG4gIGxldCBtYXRjaGVkUGFyYW1zID0ge307XG4gIGxldCBtYXRjaGVkUGF0aG5hbWUgPSBcIi9cIjtcbiAgbGV0IG1hdGNoZXMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdXRlc01ldGEubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgbWV0YSA9IHJvdXRlc01ldGFbaV07XG4gICAgbGV0IGVuZCA9IGkgPT09IHJvdXRlc01ldGEubGVuZ3RoIC0gMTtcbiAgICBsZXQgcmVtYWluaW5nUGF0aG5hbWUgPSBtYXRjaGVkUGF0aG5hbWUgPT09IFwiL1wiID8gcGF0aG5hbWUgOiBwYXRobmFtZS5zbGljZShtYXRjaGVkUGF0aG5hbWUubGVuZ3RoKSB8fCBcIi9cIjtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaFBhdGgoe1xuICAgICAgcGF0aDogbWV0YS5yZWxhdGl2ZVBhdGgsXG4gICAgICBjYXNlU2Vuc2l0aXZlOiBtZXRhLmNhc2VTZW5zaXRpdmUsXG4gICAgICBlbmRcbiAgICB9LCByZW1haW5pbmdQYXRobmFtZSk7XG4gICAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG4gICAgT2JqZWN0LmFzc2lnbihtYXRjaGVkUGFyYW1zLCBtYXRjaC5wYXJhbXMpO1xuICAgIGxldCByb3V0ZSA9IG1ldGEucm91dGU7XG4gICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgIHBhcmFtczogbWF0Y2hlZFBhcmFtcyxcbiAgICAgIHBhdGhuYW1lOiBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVdKSxcbiAgICAgIHBhdGhuYW1lQmFzZTogbm9ybWFsaXplUGF0aG5hbWUoam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lQmFzZV0pKSxcbiAgICAgIHJvdXRlXG4gICAgfSk7XG5cbiAgICBpZiAobWF0Y2gucGF0aG5hbWVCYXNlICE9PSBcIi9cIikge1xuICAgICAgbWF0Y2hlZFBhdGhuYW1lID0gam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lQmFzZV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzO1xufVxuLyoqXG4gKiBBIFBhdGhQYXR0ZXJuIGlzIHVzZWQgdG8gbWF0Y2ggb24gc29tZSBwb3J0aW9uIG9mIGEgVVJMIHBhdGhuYW1lLlxuICovXG5cblxuLyoqXG4gKiBQZXJmb3JtcyBwYXR0ZXJuIG1hdGNoaW5nIG9uIGEgVVJMIHBhdGhuYW1lIGFuZCByZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0XG4gKiB0aGUgbWF0Y2guXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNtYXRjaHBhdGhcbiAqL1xuZnVuY3Rpb24gbWF0Y2hQYXRoKHBhdHRlcm4sIHBhdGhuYW1lKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHBhdHRlcm4gPSB7XG4gICAgICBwYXRoOiBwYXR0ZXJuLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogZmFsc2UsXG4gICAgICBlbmQ6IHRydWVcbiAgICB9O1xuICB9XG5cbiAgbGV0IFttYXRjaGVyLCBwYXJhbU5hbWVzXSA9IGNvbXBpbGVQYXRoKHBhdHRlcm4ucGF0aCwgcGF0dGVybi5jYXNlU2Vuc2l0aXZlLCBwYXR0ZXJuLmVuZCk7XG4gIGxldCBtYXRjaCA9IHBhdGhuYW1lLm1hdGNoKG1hdGNoZXIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcbiAgbGV0IG1hdGNoZWRQYXRobmFtZSA9IG1hdGNoWzBdO1xuICBsZXQgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcbiAgbGV0IGNhcHR1cmVHcm91cHMgPSBtYXRjaC5zbGljZSgxKTtcbiAgbGV0IHBhcmFtcyA9IHBhcmFtTmFtZXMucmVkdWNlKChtZW1vLCBwYXJhbU5hbWUsIGluZGV4KSA9PiB7XG4gICAgLy8gV2UgbmVlZCB0byBjb21wdXRlIHRoZSBwYXRobmFtZUJhc2UgaGVyZSB1c2luZyB0aGUgcmF3IHNwbGF0IHZhbHVlXG4gICAgLy8gaW5zdGVhZCBvZiB1c2luZyBwYXJhbXNbXCIqXCJdIGxhdGVyIGJlY2F1c2UgaXQgd2lsbCBiZSBkZWNvZGVkIHRoZW5cbiAgICBpZiAocGFyYW1OYW1lID09PSBcIipcIikge1xuICAgICAgbGV0IHNwbGF0VmFsdWUgPSBjYXB0dXJlR3JvdXBzW2luZGV4XSB8fCBcIlwiO1xuICAgICAgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lLnNsaWNlKDAsIG1hdGNoZWRQYXRobmFtZS5sZW5ndGggLSBzcGxhdFZhbHVlLmxlbmd0aCkucmVwbGFjZSgvKC4pXFwvKyQvLCBcIiQxXCIpO1xuICAgIH1cblxuICAgIG1lbW9bcGFyYW1OYW1lXSA9IHNhZmVseURlY29kZVVSSUNvbXBvbmVudChjYXB0dXJlR3JvdXBzW2luZGV4XSB8fCBcIlwiLCBwYXJhbU5hbWUpO1xuICAgIHJldHVybiBtZW1vO1xuICB9LCB7fSk7XG4gIHJldHVybiB7XG4gICAgcGFyYW1zLFxuICAgIHBhdGhuYW1lOiBtYXRjaGVkUGF0aG5hbWUsXG4gICAgcGF0aG5hbWVCYXNlLFxuICAgIHBhdHRlcm5cbiAgfTtcbn1cblxuZnVuY3Rpb24gY29tcGlsZVBhdGgocGF0aCwgY2FzZVNlbnNpdGl2ZSwgZW5kKSB7XG4gIGlmIChjYXNlU2Vuc2l0aXZlID09PSB2b2lkIDApIHtcbiAgICBjYXNlU2Vuc2l0aXZlID0gZmFsc2U7XG4gIH1cblxuICBpZiAoZW5kID09PSB2b2lkIDApIHtcbiAgICBlbmQgPSB0cnVlO1xuICB9XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhwYXRoID09PSBcIipcIiB8fCAhcGF0aC5lbmRzV2l0aChcIipcIikgfHwgcGF0aC5lbmRzV2l0aChcIi8qXCIpLCBcIlJvdXRlIHBhdGggXFxcIlwiICsgcGF0aCArIFwiXFxcIiB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2VyZSBcIiArIChcIlxcXCJcIiArIHBhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIikgKyBcIlxcXCIgYmVjYXVzZSB0aGUgYCpgIGNoYXJhY3RlciBtdXN0IFwiKSArIFwiYWx3YXlzIGZvbGxvdyBhIGAvYCBpbiB0aGUgcGF0dGVybi4gVG8gZ2V0IHJpZCBvZiB0aGlzIHdhcm5pbmcsIFwiICsgKFwicGxlYXNlIGNoYW5nZSB0aGUgcm91dGUgcGF0aCB0byBcXFwiXCIgKyBwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpICsgXCJcXFwiLlwiKSkgOiB2b2lkIDA7XG4gIGxldCBwYXJhbU5hbWVzID0gW107XG4gIGxldCByZWdleHBTb3VyY2UgPSBcIl5cIiArIHBhdGgucmVwbGFjZSgvXFwvKlxcKj8kLywgXCJcIikgLy8gSWdub3JlIHRyYWlsaW5nIC8gYW5kIC8qLCB3ZSdsbCBoYW5kbGUgaXQgYmVsb3dcbiAgLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpIC8vIE1ha2Ugc3VyZSBpdCBoYXMgYSBsZWFkaW5nIC9cbiAgLnJlcGxhY2UoL1tcXFxcLiorXiQ/e318KClbXFxdXS9nLCBcIlxcXFwkJlwiKSAvLyBFc2NhcGUgc3BlY2lhbCByZWdleCBjaGFyc1xuICAucmVwbGFjZSgvOihcXHcrKS9nLCAoXywgcGFyYW1OYW1lKSA9PiB7XG4gICAgcGFyYW1OYW1lcy5wdXNoKHBhcmFtTmFtZSk7XG4gICAgcmV0dXJuIFwiKFteXFxcXC9dKylcIjtcbiAgfSk7XG5cbiAgaWYgKHBhdGguZW5kc1dpdGgoXCIqXCIpKSB7XG4gICAgcGFyYW1OYW1lcy5wdXNoKFwiKlwiKTtcbiAgICByZWdleHBTb3VyY2UgKz0gcGF0aCA9PT0gXCIqXCIgfHwgcGF0aCA9PT0gXCIvKlwiID8gXCIoLiopJFwiIC8vIEFscmVhZHkgbWF0Y2hlZCB0aGUgaW5pdGlhbCAvLCBqdXN0IG1hdGNoIHRoZSByZXN0XG4gICAgOiBcIig/OlxcXFwvKC4rKXxcXFxcLyopJFwiOyAvLyBEb24ndCBpbmNsdWRlIHRoZSAvIGluIHBhcmFtc1tcIipcIl1cbiAgfSBlbHNlIHtcbiAgICByZWdleHBTb3VyY2UgKz0gZW5kID8gXCJcXFxcLyokXCIgLy8gV2hlbiBtYXRjaGluZyB0byB0aGUgZW5kLCBpZ25vcmUgdHJhaWxpbmcgc2xhc2hlc1xuICAgIDogLy8gT3RoZXJ3aXNlLCBtYXRjaCBhIHdvcmQgYm91bmRhcnkgb3IgYSBwcm9jZWVkaW5nIC8uIFRoZSB3b3JkIGJvdW5kYXJ5IHJlc3RyaWN0c1xuICAgIC8vIHBhcmVudCByb3V0ZXMgdG8gbWF0Y2hpbmcgb25seSB0aGVpciBvd24gd29yZHMgYW5kIG5vdGhpbmcgbW9yZSwgZS5nLiBwYXJlbnRcbiAgICAvLyByb3V0ZSBcIi9ob21lXCIgc2hvdWxkIG5vdCBtYXRjaCBcIi9ob21lMlwiLlxuICAgIC8vIEFkZGl0aW9uYWxseSwgYWxsb3cgcGF0aHMgc3RhcnRpbmcgd2l0aCBgLmAsIGAtYCwgYH5gLCBhbmQgdXJsLWVuY29kZWQgZW50aXRpZXMsXG4gICAgLy8gYnV0IGRvIG5vdCBjb25zdW1lIHRoZSBjaGFyYWN0ZXIgaW4gdGhlIG1hdGNoZWQgcGF0aCBzbyB0aGV5IGNhbiBtYXRjaCBhZ2FpbnN0XG4gICAgLy8gbmVzdGVkIHBhdGhzLlxuICAgIFwiKD86KD89Wy5+LV18JVswLTlBLUZdezJ9KXxcXFxcYnxcXFxcL3wkKVwiO1xuICB9XG5cbiAgbGV0IG1hdGNoZXIgPSBuZXcgUmVnRXhwKHJlZ2V4cFNvdXJjZSwgY2FzZVNlbnNpdGl2ZSA/IHVuZGVmaW5lZCA6IFwiaVwiKTtcbiAgcmV0dXJuIFttYXRjaGVyLCBwYXJhbU5hbWVzXTtcbn1cblxuZnVuY3Rpb24gc2FmZWx5RGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlLCBwYXJhbU5hbWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIlRoZSB2YWx1ZSBmb3IgdGhlIFVSTCBwYXJhbSBcXFwiXCIgKyBwYXJhbU5hbWUgKyBcIlxcXCIgd2lsbCBub3QgYmUgZGVjb2RlZCBiZWNhdXNlXCIgKyAoXCIgdGhlIHN0cmluZyBcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiBpcyBhIG1hbGZvcm1lZCBVUkwgc2VnbWVudC4gVGhpcyBpcyBwcm9iYWJseVwiKSArIChcIiBkdWUgdG8gYSBiYWQgcGVyY2VudCBlbmNvZGluZyAoXCIgKyBlcnJvciArIFwiKS5cIikpIDogdm9pZCAwO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIGEgcmVzb2x2ZWQgcGF0aCBvYmplY3QgcmVsYXRpdmUgdG8gdGhlIGdpdmVuIHBhdGhuYW1lLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjcmVzb2x2ZXBhdGhcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlc29sdmVQYXRoKHRvLCBmcm9tUGF0aG5hbWUpIHtcbiAgaWYgKGZyb21QYXRobmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgZnJvbVBhdGhuYW1lID0gXCIvXCI7XG4gIH1cblxuICBsZXQge1xuICAgIHBhdGhuYW1lOiB0b1BhdGhuYW1lLFxuICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgaGFzaCA9IFwiXCJcbiAgfSA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0bztcbiAgbGV0IHBhdGhuYW1lID0gdG9QYXRobmFtZSA/IHRvUGF0aG5hbWUuc3RhcnRzV2l0aChcIi9cIikgPyB0b1BhdGhuYW1lIDogcmVzb2x2ZVBhdGhuYW1lKHRvUGF0aG5hbWUsIGZyb21QYXRobmFtZSkgOiBmcm9tUGF0aG5hbWU7XG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBub3JtYWxpemVTZWFyY2goc2VhcmNoKSxcbiAgICBoYXNoOiBub3JtYWxpemVIYXNoKGhhc2gpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVQYXRobmFtZShyZWxhdGl2ZVBhdGgsIGZyb21QYXRobmFtZSkge1xuICBsZXQgc2VnbWVudHMgPSBmcm9tUGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5zcGxpdChcIi9cIik7XG4gIGxldCByZWxhdGl2ZVNlZ21lbnRzID0gcmVsYXRpdmVQYXRoLnNwbGl0KFwiL1wiKTtcbiAgcmVsYXRpdmVTZWdtZW50cy5mb3JFYWNoKHNlZ21lbnQgPT4ge1xuICAgIGlmIChzZWdtZW50ID09PSBcIi4uXCIpIHtcbiAgICAgIC8vIEtlZXAgdGhlIHJvb3QgXCJcIiBzZWdtZW50IHNvIHRoZSBwYXRobmFtZSBzdGFydHMgYXQgL1xuICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHNlZ21lbnRzLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudCAhPT0gXCIuXCIpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCA+IDEgPyBzZWdtZW50cy5qb2luKFwiL1wiKSA6IFwiL1wiO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlVG8odG9BcmcsIHJvdXRlUGF0aG5hbWVzLCBsb2NhdGlvblBhdGhuYW1lKSB7XG4gIGxldCB0byA9IHR5cGVvZiB0b0FyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0b0FyZykgOiB0b0FyZztcbiAgbGV0IHRvUGF0aG5hbWUgPSB0b0FyZyA9PT0gXCJcIiB8fCB0by5wYXRobmFtZSA9PT0gXCJcIiA/IFwiL1wiIDogdG8ucGF0aG5hbWU7IC8vIElmIGEgcGF0aG5hbWUgaXMgZXhwbGljaXRseSBwcm92aWRlZCBpbiBgdG9gLCBpdCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlXG4gIC8vIHJvdXRlIGNvbnRleHQuIFRoaXMgaXMgZXhwbGFpbmVkIGluIGBOb3RlIG9uIGA8TGluayB0bz5gIHZhbHVlc2AgaW4gb3VyXG4gIC8vIG1pZ3JhdGlvbiBndWlkZSBmcm9tIHY1IGFzIGEgbWVhbnMgb2YgZGlzYW1iaWd1YXRpb24gYmV0d2VlbiBgdG9gIHZhbHVlc1xuICAvLyB0aGF0IGJlZ2luIHdpdGggYC9gIGFuZCB0aG9zZSB0aGF0IGRvIG5vdC4gSG93ZXZlciwgdGhpcyBpcyBwcm9ibGVtYXRpYyBmb3JcbiAgLy8gYHRvYCB2YWx1ZXMgdGhhdCBkbyBub3QgcHJvdmlkZSBhIHBhdGhuYW1lLiBgdG9gIGNhbiBzaW1wbHkgYmUgYSBzZWFyY2ggb3JcbiAgLy8gaGFzaCBzdHJpbmcsIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkIGFzc3VtZSB0aGF0IHRoZSBuYXZpZ2F0aW9uIGlzIHJlbGF0aXZlXG4gIC8vIHRvIHRoZSBjdXJyZW50IGxvY2F0aW9uJ3MgcGF0aG5hbWUgYW5kICpub3QqIHRoZSByb3V0ZSBwYXRobmFtZS5cblxuICBsZXQgZnJvbTtcblxuICBpZiAodG9QYXRobmFtZSA9PSBudWxsKSB7XG4gICAgZnJvbSA9IGxvY2F0aW9uUGF0aG5hbWU7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHJvdXRlUGF0aG5hbWVJbmRleCA9IHJvdXRlUGF0aG5hbWVzLmxlbmd0aCAtIDE7XG5cbiAgICBpZiAodG9QYXRobmFtZS5zdGFydHNXaXRoKFwiLi5cIikpIHtcbiAgICAgIGxldCB0b1NlZ21lbnRzID0gdG9QYXRobmFtZS5zcGxpdChcIi9cIik7IC8vIEVhY2ggbGVhZGluZyAuLiBzZWdtZW50IG1lYW5zIFwiZ28gdXAgb25lIHJvdXRlXCIgaW5zdGVhZCBvZiBcImdvIHVwIG9uZVxuICAgICAgLy8gVVJMIHNlZ21lbnRcIi4gIFRoaXMgaXMgYSBrZXkgZGlmZmVyZW5jZSBmcm9tIGhvdyA8YSBocmVmPiB3b3JrcyBhbmQgYVxuICAgICAgLy8gbWFqb3IgcmVhc29uIHdlIGNhbGwgdGhpcyBhIFwidG9cIiB2YWx1ZSBpbnN0ZWFkIG9mIGEgXCJocmVmXCIuXG5cbiAgICAgIHdoaWxlICh0b1NlZ21lbnRzWzBdID09PSBcIi4uXCIpIHtcbiAgICAgICAgdG9TZWdtZW50cy5zaGlmdCgpO1xuICAgICAgICByb3V0ZVBhdGhuYW1lSW5kZXggLT0gMTtcbiAgICAgIH1cblxuICAgICAgdG8ucGF0aG5hbWUgPSB0b1NlZ21lbnRzLmpvaW4oXCIvXCIpO1xuICAgIH0gLy8gSWYgdGhlcmUgYXJlIG1vcmUgXCIuLlwiIHNlZ21lbnRzIHRoYW4gcGFyZW50IHJvdXRlcywgcmVzb2x2ZSByZWxhdGl2ZSB0b1xuICAgIC8vIHRoZSByb290IC8gVVJMLlxuXG5cbiAgICBmcm9tID0gcm91dGVQYXRobmFtZUluZGV4ID49IDAgPyByb3V0ZVBhdGhuYW1lc1tyb3V0ZVBhdGhuYW1lSW5kZXhdIDogXCIvXCI7XG4gIH1cblxuICBsZXQgcGF0aCA9IHJlc29sdmVQYXRoKHRvLCBmcm9tKTsgLy8gRW5zdXJlIHRoZSBwYXRobmFtZSBoYXMgYSB0cmFpbGluZyBzbGFzaCBpZiB0aGUgb3JpZ2luYWwgdG8gdmFsdWUgaGFkIG9uZS5cblxuICBpZiAodG9QYXRobmFtZSAmJiB0b1BhdGhuYW1lICE9PSBcIi9cIiAmJiB0b1BhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSAmJiAhcGF0aC5wYXRobmFtZS5lbmRzV2l0aChcIi9cIikpIHtcbiAgICBwYXRoLnBhdGhuYW1lICs9IFwiL1wiO1xuICB9XG5cbiAgcmV0dXJuIHBhdGg7XG59XG5mdW5jdGlvbiBnZXRUb1BhdGhuYW1lKHRvKSB7XG4gIC8vIEVtcHR5IHN0cmluZ3Mgc2hvdWxkIGJlIHRyZWF0ZWQgdGhlIHNhbWUgYXMgLyBwYXRoc1xuICByZXR1cm4gdG8gPT09IFwiXCIgfHwgdG8ucGF0aG5hbWUgPT09IFwiXCIgPyBcIi9cIiA6IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykucGF0aG5hbWUgOiB0by5wYXRobmFtZTtcbn1cbmZ1bmN0aW9uIHN0cmlwQmFzZW5hbWUocGF0aG5hbWUsIGJhc2VuYW1lKSB7XG4gIGlmIChiYXNlbmFtZSA9PT0gXCIvXCIpIHJldHVybiBwYXRobmFtZTtcblxuICBpZiAoIXBhdGhuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChiYXNlbmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGV0IG5leHRDaGFyID0gcGF0aG5hbWUuY2hhckF0KGJhc2VuYW1lLmxlbmd0aCk7XG5cbiAgaWYgKG5leHRDaGFyICYmIG5leHRDaGFyICE9PSBcIi9cIikge1xuICAgIC8vIHBhdGhuYW1lIGRvZXMgbm90IHN0YXJ0IHdpdGggYmFzZW5hbWUvXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gcGF0aG5hbWUuc2xpY2UoYmFzZW5hbWUubGVuZ3RoKSB8fCBcIi9cIjtcbn1cbmNvbnN0IGpvaW5QYXRocyA9IHBhdGhzID0+IHBhdGhzLmpvaW4oXCIvXCIpLnJlcGxhY2UoL1xcL1xcLysvZywgXCIvXCIpO1xuY29uc3Qgbm9ybWFsaXplUGF0aG5hbWUgPSBwYXRobmFtZSA9PiBwYXRobmFtZS5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpO1xuXG5jb25zdCBub3JtYWxpemVTZWFyY2ggPSBzZWFyY2ggPT4gIXNlYXJjaCB8fCBzZWFyY2ggPT09IFwiP1wiID8gXCJcIiA6IHNlYXJjaC5zdGFydHNXaXRoKFwiP1wiKSA/IHNlYXJjaCA6IFwiP1wiICsgc2VhcmNoO1xuXG5jb25zdCBub3JtYWxpemVIYXNoID0gaGFzaCA9PiAhaGFzaCB8fCBoYXNoID09PSBcIiNcIiA/IFwiXCIgOiBoYXNoLnN0YXJ0c1dpdGgoXCIjXCIpID8gaGFzaCA6IFwiI1wiICsgaGFzaDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmdWxsIGhyZWYgZm9yIHRoZSBnaXZlbiBcInRvXCIgdmFsdWUuIFRoaXMgaXMgdXNlZnVsIGZvciBidWlsZGluZ1xuICogY3VzdG9tIGxpbmtzIHRoYXQgYXJlIGFsc28gYWNjZXNzaWJsZSBhbmQgcHJlc2VydmUgcmlnaHQtY2xpY2sgYmVoYXZpb3IuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VocmVmXG4gKi9cblxuZnVuY3Rpb24gdXNlSHJlZih0bykge1xuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gIFwidXNlSHJlZigpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZSxcbiAgICBuYXZpZ2F0b3JcbiAgfSA9IHVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQge1xuICAgIGhhc2gsXG4gICAgcGF0aG5hbWUsXG4gICAgc2VhcmNoXG4gIH0gPSB1c2VSZXNvbHZlZFBhdGgodG8pO1xuICBsZXQgam9pbmVkUGF0aG5hbWUgPSBwYXRobmFtZTtcblxuICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgbGV0IHRvUGF0aG5hbWUgPSBnZXRUb1BhdGhuYW1lKHRvKTtcbiAgICBsZXQgZW5kc1dpdGhTbGFzaCA9IHRvUGF0aG5hbWUgIT0gbnVsbCAmJiB0b1BhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKTtcbiAgICBqb2luZWRQYXRobmFtZSA9IHBhdGhuYW1lID09PSBcIi9cIiA/IGJhc2VuYW1lICsgKGVuZHNXaXRoU2xhc2ggPyBcIi9cIiA6IFwiXCIpIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aG5hbWVdKTtcbiAgfVxuXG4gIHJldHVybiBuYXZpZ2F0b3IuY3JlYXRlSHJlZih7XG4gICAgcGF0aG5hbWU6IGpvaW5lZFBhdGhuYW1lLFxuICAgIHNlYXJjaCxcbiAgICBoYXNoXG4gIH0pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjb21wb25lbnQgaXMgYSBkZXNjZW5kYW50IG9mIGEgPFJvdXRlcj4uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VpbnJvdXRlcmNvbnRleHRcbiAqL1xuXG5mdW5jdGlvbiB1c2VJblJvdXRlckNvbnRleHQoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkgIT0gbnVsbDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBsb2NhdGlvbiBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgVVJMIGluIHdlYlxuICogYnJvd3NlcnMuXG4gKlxuICogTm90ZTogSWYgeW91J3JlIHVzaW5nIHRoaXMgaXQgbWF5IG1lYW4geW91J3JlIGRvaW5nIHNvbWUgb2YgeW91ciBvd25cbiAqIFwicm91dGluZ1wiIGluIHlvdXIgYXBwLCBhbmQgd2UnZCBsaWtlIHRvIGtub3cgd2hhdCB5b3VyIHVzZSBjYXNlIGlzLiBXZSBtYXlcbiAqIGJlIGFibGUgdG8gcHJvdmlkZSBzb21ldGhpbmcgaGlnaGVyLWxldmVsIHRvIGJldHRlciBzdWl0IHlvdXIgbmVlZHMuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2Vsb2NhdGlvblxuICovXG5cbmZ1bmN0aW9uIHVzZUxvY2F0aW9uKCkge1xuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gIFwidXNlTG9jYXRpb24oKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiB1c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkubG9jYXRpb247XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiBhY3Rpb24gd2hpY2ggZGVzY3JpYmVzIGhvdyB0aGUgcm91dGVyIGNhbWUgdG9cbiAqIHRoZSBjdXJyZW50IGxvY2F0aW9uLCBlaXRoZXIgYnkgYSBwb3AsIHB1c2gsIG9yIHJlcGxhY2Ugb24gdGhlIGhpc3Rvcnkgc3RhY2suXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VuYXZpZ2F0aW9udHlwZVxuICovXG5cbmZ1bmN0aW9uIHVzZU5hdmlnYXRpb25UeXBlKCkge1xuICByZXR1cm4gdXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLm5hdmlnYXRpb25UeXBlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIFVSTCBmb3IgdGhlIGdpdmVuIFwidG9cIiB2YWx1ZSBtYXRjaGVzIHRoZSBjdXJyZW50IFVSTC5cbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBjb21wb25lbnRzIHRoYXQgbmVlZCB0byBrbm93IFwiYWN0aXZlXCIgc3RhdGUsIGUuZy5cbiAqIDxOYXZMaW5rPi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZW1hdGNoXG4gKi9cblxuZnVuY3Rpb24gdXNlTWF0Y2gocGF0dGVybikge1xuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gIFwidXNlTWF0Y2goKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGxldCB7XG4gICAgcGF0aG5hbWVcbiAgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IG1hdGNoUGF0aChwYXR0ZXJuLCBwYXRobmFtZSksIFtwYXRobmFtZSwgcGF0dGVybl0pO1xufVxuLyoqXG4gKiBUaGUgaW50ZXJmYWNlIGZvciB0aGUgbmF2aWdhdGUoKSBmdW5jdGlvbiByZXR1cm5lZCBmcm9tIHVzZU5hdmlnYXRlKCkuXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGltcGVyYXRpdmUgbWV0aG9kIGZvciBjaGFuZ2luZyB0aGUgbG9jYXRpb24uIFVzZWQgYnkgPExpbms+cywgYnV0XG4gKiBtYXkgYWxzbyBiZSB1c2VkIGJ5IG90aGVyIGVsZW1lbnRzIHRvIGNoYW5nZSB0aGUgbG9jYXRpb24uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VuYXZpZ2F0ZVxuICovXG5mdW5jdGlvbiB1c2VOYXZpZ2F0ZSgpIHtcbiAgIXVzZUluUm91dGVyQ29udGV4dCgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICBcInVzZU5hdmlnYXRlKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBsZXQge1xuICAgIGJhc2VuYW1lLFxuICAgIG5hdmlnYXRvclxuICB9ID0gdXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB7XG4gICAgbWF0Y2hlc1xuICB9ID0gdXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQge1xuICAgIHBhdGhuYW1lOiBsb2NhdGlvblBhdGhuYW1lXG4gIH0gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgcm91dGVQYXRobmFtZXNKc29uID0gSlNPTi5zdHJpbmdpZnkobWF0Y2hlcy5tYXAobWF0Y2ggPT4gbWF0Y2gucGF0aG5hbWVCYXNlKSk7XG4gIGxldCBhY3RpdmVSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGFjdGl2ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgfSk7XG4gIGxldCBuYXZpZ2F0ZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICh0bywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGFjdGl2ZVJlZi5jdXJyZW50LCBcIllvdSBzaG91bGQgY2FsbCBuYXZpZ2F0ZSgpIGluIGEgUmVhY3QudXNlRWZmZWN0KCksIG5vdCB3aGVuIFwiICsgXCJ5b3VyIGNvbXBvbmVudCBpcyBmaXJzdCByZW5kZXJlZC5cIikgOiB2b2lkIDA7XG4gICAgaWYgKCFhY3RpdmVSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgaWYgKHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIikge1xuICAgICAgbmF2aWdhdG9yLmdvKHRvKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgcGF0aCA9IHJlc29sdmVUbyh0bywgSlNPTi5wYXJzZShyb3V0ZVBhdGhuYW1lc0pzb24pLCBsb2NhdGlvblBhdGhuYW1lKTtcblxuICAgIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICAgIHBhdGgucGF0aG5hbWUgPSBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XG4gICAgfVxuXG4gICAgKCEhb3B0aW9ucy5yZXBsYWNlID8gbmF2aWdhdG9yLnJlcGxhY2UgOiBuYXZpZ2F0b3IucHVzaCkocGF0aCwgb3B0aW9ucy5zdGF0ZSk7XG4gIH0sIFtiYXNlbmFtZSwgbmF2aWdhdG9yLCByb3V0ZVBhdGhuYW1lc0pzb24sIGxvY2F0aW9uUGF0aG5hbWVdKTtcbiAgcmV0dXJuIG5hdmlnYXRlO1xufVxuY29uc3QgT3V0bGV0Q29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KG51bGwpO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb250ZXh0IChpZiBwcm92aWRlZCkgZm9yIHRoZSBjaGlsZCByb3V0ZSBhdCB0aGlzIGxldmVsIG9mIHRoZSByb3V0ZVxuICogaGllcmFyY2h5LlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VvdXRsZXRjb250ZXh0XG4gKi9cblxuZnVuY3Rpb24gdXNlT3V0bGV0Q29udGV4dCgpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoT3V0bGV0Q29udGV4dCk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGVsZW1lbnQgZm9yIHRoZSBjaGlsZCByb3V0ZSBhdCB0aGlzIGxldmVsIG9mIHRoZSByb3V0ZVxuICogaGllcmFyY2h5LiBVc2VkIGludGVybmFsbHkgYnkgPE91dGxldD4gdG8gcmVuZGVyIGNoaWxkIHJvdXRlcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZW91dGxldFxuICovXG5cbmZ1bmN0aW9uIHVzZU91dGxldChjb250ZXh0KSB7XG4gIGxldCBvdXRsZXQgPSB1c2VDb250ZXh0KFJvdXRlQ29udGV4dCkub3V0bGV0O1xuXG4gIGlmIChvdXRsZXQpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL2NyZWF0ZUVsZW1lbnQoT3V0bGV0Q29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IGNvbnRleHRcbiAgICB9LCBvdXRsZXQpO1xuICB9XG5cbiAgcmV0dXJuIG91dGxldDtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3Qgb2Yga2V5L3ZhbHVlIHBhaXJzIG9mIHRoZSBkeW5hbWljIHBhcmFtcyBmcm9tIHRoZSBjdXJyZW50XG4gKiBVUkwgdGhhdCB3ZXJlIG1hdGNoZWQgYnkgdGhlIHJvdXRlIHBhdGguXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VwYXJhbXNcbiAqL1xuXG5mdW5jdGlvbiB1c2VQYXJhbXMoKSB7XG4gIGxldCB7XG4gICAgbWF0Y2hlc1xuICB9ID0gdXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgcm91dGVNYXRjaCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhcmFtcyA6IHt9O1xufVxuLyoqXG4gKiBSZXNvbHZlcyB0aGUgcGF0aG5hbWUgb2YgdGhlIGdpdmVuIGB0b2AgdmFsdWUgYWdhaW5zdCB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZXJlc29sdmVkcGF0aFxuICovXG5cbmZ1bmN0aW9uIHVzZVJlc29sdmVkUGF0aCh0bykge1xuICBsZXQge1xuICAgIG1hdGNoZXNcbiAgfSA9IHVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHtcbiAgICBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZVxuICB9ID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHJvdXRlUGF0aG5hbWVzSnNvbiA9IEpTT04uc3RyaW5naWZ5KG1hdGNoZXMubWFwKG1hdGNoID0+IG1hdGNoLnBhdGhuYW1lQmFzZSkpO1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiByZXNvbHZlVG8odG8sIEpTT04ucGFyc2Uocm91dGVQYXRobmFtZXNKc29uKSwgbG9jYXRpb25QYXRobmFtZSksIFt0bywgcm91dGVQYXRobmFtZXNKc29uLCBsb2NhdGlvblBhdGhuYW1lXSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGVsZW1lbnQgb2YgdGhlIHJvdXRlIHRoYXQgbWF0Y2hlZCB0aGUgY3VycmVudCBsb2NhdGlvbiwgcHJlcGFyZWRcbiAqIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dCB0byByZW5kZXIgdGhlIHJlbWFpbmRlciBvZiB0aGUgcm91dGUgdHJlZS4gUm91dGVcbiAqIGVsZW1lbnRzIGluIHRoZSB0cmVlIG11c3QgcmVuZGVyIGFuIDxPdXRsZXQ+IHRvIHJlbmRlciB0aGVpciBjaGlsZCByb3V0ZSdzXG4gKiBlbGVtZW50LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjdXNlcm91dGVzXG4gKi9cblxuZnVuY3Rpb24gdXNlUm91dGVzKHJvdXRlcywgbG9jYXRpb25BcmcpIHtcbiAgIXVzZUluUm91dGVyQ29udGV4dCgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICBcInVzZVJvdXRlcygpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IHtcbiAgICBtYXRjaGVzOiBwYXJlbnRNYXRjaGVzXG4gIH0gPSB1c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZU1hdGNoID0gcGFyZW50TWF0Y2hlc1twYXJlbnRNYXRjaGVzLmxlbmd0aCAtIDFdO1xuICBsZXQgcGFyZW50UGFyYW1zID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGFyYW1zIDoge307XG4gIGxldCBwYXJlbnRQYXRobmFtZSA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhdGhuYW1lIDogXCIvXCI7XG4gIGxldCBwYXJlbnRQYXRobmFtZUJhc2UgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXRobmFtZUJhc2UgOiBcIi9cIjtcbiAgbGV0IHBhcmVudFJvdXRlID0gcm91dGVNYXRjaCAmJiByb3V0ZU1hdGNoLnJvdXRlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAvLyBZb3Ugd29uJ3QgZ2V0IGEgd2FybmluZyBhYm91dCAyIGRpZmZlcmVudCA8Um91dGVzPiB1bmRlciBhIDxSb3V0ZT5cbiAgICAvLyB3aXRob3V0IGEgdHJhaWxpbmcgKiwgYnV0IHRoaXMgaXMgYSBiZXN0LWVmZm9ydCB3YXJuaW5nIGFueXdheSBzaW5jZSB3ZVxuICAgIC8vIGNhbm5vdCBldmVuIGdpdmUgdGhlIHdhcm5pbmcgdW5sZXNzIHRoZXkgbGFuZCBhdCB0aGUgcGFyZW50IHJvdXRlLlxuICAgIC8vXG4gICAgLy8gRXhhbXBsZTpcbiAgICAvL1xuICAgIC8vIDxSb3V0ZXM+XG4gICAgLy8gICB7LyogVGhpcyByb3V0ZSBwYXRoIE1VU1QgZW5kIHdpdGggLyogYmVjYXVzZSBvdGhlcndpc2VcbiAgICAvLyAgICAgICBpdCB3aWxsIG5ldmVyIG1hdGNoIC9ibG9nL3Bvc3QvMTIzICovfVxuICAgIC8vICAgPFJvdXRlIHBhdGg9XCJibG9nXCIgZWxlbWVudD17PEJsb2cgLz59IC8+XG4gICAgLy8gICA8Um91dGUgcGF0aD1cImJsb2cvZmVlZFwiIGVsZW1lbnQ9ezxCbG9nRmVlZCAvPn0gLz5cbiAgICAvLyA8L1JvdXRlcz5cbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uIEJsb2coKSB7XG4gICAgLy8gICByZXR1cm4gKFxuICAgIC8vICAgICA8Um91dGVzPlxuICAgIC8vICAgICAgIDxSb3V0ZSBwYXRoPVwicG9zdC86aWRcIiBlbGVtZW50PXs8UG9zdCAvPn0gLz5cbiAgICAvLyAgICAgPC9Sb3V0ZXM+XG4gICAgLy8gICApO1xuICAgIC8vIH1cbiAgICBsZXQgcGFyZW50UGF0aCA9IHBhcmVudFJvdXRlICYmIHBhcmVudFJvdXRlLnBhdGggfHwgXCJcIjtcbiAgICB3YXJuaW5nT25jZShwYXJlbnRQYXRobmFtZSwgIXBhcmVudFJvdXRlIHx8IHBhcmVudFBhdGguZW5kc1dpdGgoXCIqXCIpLCBcIllvdSByZW5kZXJlZCBkZXNjZW5kYW50IDxSb3V0ZXM+IChvciBjYWxsZWQgYHVzZVJvdXRlcygpYCkgYXQgXCIgKyAoXCJcXFwiXCIgKyBwYXJlbnRQYXRobmFtZSArIFwiXFxcIiAodW5kZXIgPFJvdXRlIHBhdGg9XFxcIlwiICsgcGFyZW50UGF0aCArIFwiXFxcIj4pIGJ1dCB0aGUgXCIpICsgXCJwYXJlbnQgcm91dGUgcGF0aCBoYXMgbm8gdHJhaWxpbmcgXFxcIipcXFwiLiBUaGlzIG1lYW5zIGlmIHlvdSBuYXZpZ2F0ZSBcIiArIFwiZGVlcGVyLCB0aGUgcGFyZW50IHdvbid0IG1hdGNoIGFueW1vcmUgYW5kIHRoZXJlZm9yZSB0aGUgY2hpbGQgXCIgKyBcInJvdXRlcyB3aWxsIG5ldmVyIHJlbmRlci5cXG5cXG5cIiArIChcIlBsZWFzZSBjaGFuZ2UgdGhlIHBhcmVudCA8Um91dGUgcGF0aD1cXFwiXCIgKyBwYXJlbnRQYXRoICsgXCJcXFwiPiB0byA8Um91dGUgXCIpICsgKFwicGF0aD1cXFwiXCIgKyAocGFyZW50UGF0aCA9PT0gXCIvXCIgPyBcIipcIiA6IHBhcmVudFBhdGggKyBcIi8qXCIpICsgXCJcXFwiPi5cIikpO1xuICB9XG5cbiAgbGV0IGxvY2F0aW9uRnJvbUNvbnRleHQgPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgbG9jYXRpb247XG5cbiAgaWYgKGxvY2F0aW9uQXJnKSB7XG4gICAgdmFyIF9wYXJzZWRMb2NhdGlvbkFyZyRwYTtcblxuICAgIGxldCBwYXJzZWRMb2NhdGlvbkFyZyA9IHR5cGVvZiBsb2NhdGlvbkFyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbkFyZykgOiBsb2NhdGlvbkFyZztcbiAgICAhKHBhcmVudFBhdGhuYW1lQmFzZSA9PT0gXCIvXCIgfHwgKChfcGFyc2VkTG9jYXRpb25BcmckcGEgPSBwYXJzZWRMb2NhdGlvbkFyZy5wYXRobmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wYXJzZWRMb2NhdGlvbkFyZyRwYS5zdGFydHNXaXRoKHBhcmVudFBhdGhuYW1lQmFzZSkpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJXaGVuIG92ZXJyaWRpbmcgdGhlIGxvY2F0aW9uIHVzaW5nIGA8Um91dGVzIGxvY2F0aW9uPmAgb3IgYHVzZVJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uKWAsIFwiICsgXCJ0aGUgbG9jYXRpb24gcGF0aG5hbWUgbXVzdCBiZWdpbiB3aXRoIHRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgXCIgKyAoXCJtYXRjaGVkIGJ5IGFsbCBwYXJlbnQgcm91dGVzLiBUaGUgY3VycmVudCBwYXRobmFtZSBiYXNlIGlzIFxcXCJcIiArIHBhcmVudFBhdGhuYW1lQmFzZSArIFwiXFxcIiBcIikgKyAoXCJidXQgcGF0aG5hbWUgXFxcIlwiICsgcGFyc2VkTG9jYXRpb25BcmcucGF0aG5hbWUgKyBcIlxcXCIgd2FzIGdpdmVuIGluIHRoZSBgbG9jYXRpb25gIHByb3AuXCIpKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgbG9jYXRpb24gPSBwYXJzZWRMb2NhdGlvbkFyZztcbiAgfSBlbHNlIHtcbiAgICBsb2NhdGlvbiA9IGxvY2F0aW9uRnJvbUNvbnRleHQ7XG4gIH1cblxuICBsZXQgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSB8fCBcIi9cIjtcbiAgbGV0IHJlbWFpbmluZ1BhdGhuYW1lID0gcGFyZW50UGF0aG5hbWVCYXNlID09PSBcIi9cIiA/IHBhdGhuYW1lIDogcGF0aG5hbWUuc2xpY2UocGFyZW50UGF0aG5hbWVCYXNlLmxlbmd0aCkgfHwgXCIvXCI7XG4gIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzLCB7XG4gICAgcGF0aG5hbWU6IHJlbWFpbmluZ1BhdGhuYW1lXG4gIH0pO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKHBhcmVudFJvdXRlIHx8IG1hdGNoZXMgIT0gbnVsbCwgXCJObyByb3V0ZXMgbWF0Y2hlZCBsb2NhdGlvbiBcXFwiXCIgKyBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCArIGxvY2F0aW9uLmhhc2ggKyBcIlxcXCIgXCIpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcobWF0Y2hlcyA9PSBudWxsIHx8IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5lbGVtZW50ICE9PSB1bmRlZmluZWQsIFwiTWF0Y2hlZCBsZWFmIHJvdXRlIGF0IGxvY2F0aW9uIFxcXCJcIiArIGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoICsgbG9jYXRpb24uaGFzaCArIFwiXFxcIiBkb2VzIG5vdCBoYXZlIGFuIGVsZW1lbnQuIFwiICsgXCJUaGlzIG1lYW5zIGl0IHdpbGwgcmVuZGVyIGFuIDxPdXRsZXQgLz4gd2l0aCBhIG51bGwgdmFsdWUgYnkgZGVmYXVsdCByZXN1bHRpbmcgaW4gYW4gXFxcImVtcHR5XFxcIiBwYWdlLlwiKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHJldHVybiBfcmVuZGVyTWF0Y2hlcyhtYXRjaGVzICYmIG1hdGNoZXMubWFwKG1hdGNoID0+IE9iamVjdC5hc3NpZ24oe30sIG1hdGNoLCB7XG4gICAgcGFyYW1zOiBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnRQYXJhbXMsIG1hdGNoLnBhcmFtcyksXG4gICAgcGF0aG5hbWU6IGpvaW5QYXRocyhbcGFyZW50UGF0aG5hbWVCYXNlLCBtYXRjaC5wYXRobmFtZV0pLFxuICAgIHBhdGhuYW1lQmFzZTogbWF0Y2gucGF0aG5hbWVCYXNlID09PSBcIi9cIiA/IHBhcmVudFBhdGhuYW1lQmFzZSA6IGpvaW5QYXRocyhbcGFyZW50UGF0aG5hbWVCYXNlLCBtYXRjaC5wYXRobmFtZUJhc2VdKVxuICB9KSksIHBhcmVudE1hdGNoZXMpO1xufVxuZnVuY3Rpb24gX3JlbmRlck1hdGNoZXMobWF0Y2hlcywgcGFyZW50TWF0Y2hlcykge1xuICBpZiAocGFyZW50TWF0Y2hlcyA9PT0gdm9pZCAwKSB7XG4gICAgcGFyZW50TWF0Y2hlcyA9IFtdO1xuICB9XG5cbiAgaWYgKG1hdGNoZXMgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBtYXRjaGVzLnJlZHVjZVJpZ2h0KChvdXRsZXQsIG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovY3JlYXRlRWxlbWVudChSb3V0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIGNoaWxkcmVuOiBtYXRjaC5yb3V0ZS5lbGVtZW50ICE9PSB1bmRlZmluZWQgPyBtYXRjaC5yb3V0ZS5lbGVtZW50IDogb3V0bGV0LFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgb3V0bGV0LFxuICAgICAgICBtYXRjaGVzOiBwYXJlbnRNYXRjaGVzLmNvbmNhdChtYXRjaGVzLnNsaWNlKDAsIGluZGV4ICsgMSkpXG4gICAgICB9XG4gICAgfSk7XG4gIH0sIG51bGwpO1xufVxuXG4vKipcbiAqIEEgPFJvdXRlcj4gdGhhdCBzdG9yZXMgYWxsIGVudHJpZXMgaW4gbWVtb3J5LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjbWVtb3J5cm91dGVyXG4gKi9cbmZ1bmN0aW9uIE1lbW9yeVJvdXRlcihfcmVmKSB7XG4gIGxldCB7XG4gICAgYmFzZW5hbWUsXG4gICAgY2hpbGRyZW4sXG4gICAgaW5pdGlhbEVudHJpZXMsXG4gICAgaW5pdGlhbEluZGV4XG4gIH0gPSBfcmVmO1xuICBsZXQgaGlzdG9yeVJlZiA9IHVzZVJlZigpO1xuXG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZU1lbW9yeUhpc3Rvcnkoe1xuICAgICAgaW5pdGlhbEVudHJpZXMsXG4gICAgICBpbml0aWFsSW5kZXhcbiAgICB9KTtcbiAgfVxuXG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnldKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9jcmVhdGVFbGVtZW50KFJvdXRlciwge1xuICAgIGJhc2VuYW1lOiBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5hY3Rpb24sXG4gICAgbmF2aWdhdG9yOiBoaXN0b3J5XG4gIH0pO1xufVxuXG4vKipcbiAqIENoYW5nZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gKlxuICogTm90ZTogVGhpcyBBUEkgaXMgbW9zdGx5IHVzZWZ1bCBpbiBSZWFjdC5Db21wb25lbnQgc3ViY2xhc3NlcyB0aGF0IGFyZSBub3RcbiAqIGFibGUgdG8gdXNlIGhvb2tzLiBJbiBmdW5jdGlvbmFsIGNvbXBvbmVudHMsIHdlIHJlY29tbWVuZCB5b3UgdXNlIHRoZVxuICogYHVzZU5hdmlnYXRlYCBob29rIGluc3RlYWQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNuYXZpZ2F0ZVxuICovXG5mdW5jdGlvbiBOYXZpZ2F0ZShfcmVmMikge1xuICBsZXQge1xuICAgIHRvLFxuICAgIHJlcGxhY2UsXG4gICAgc3RhdGVcbiAgfSA9IF9yZWYyO1xuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mXG4gIC8vIHRoZSByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gIFwiPE5hdmlnYXRlPiBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoIXVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpLnN0YXRpYywgXCI8TmF2aWdhdGU+IG11c3Qgbm90IGJlIHVzZWQgb24gdGhlIGluaXRpYWwgcmVuZGVyIGluIGEgPFN0YXRpY1JvdXRlcj4uIFwiICsgXCJUaGlzIGlzIGEgbm8tb3AsIGJ1dCB5b3Ugc2hvdWxkIG1vZGlmeSB5b3VyIGNvZGUgc28gdGhlIDxOYXZpZ2F0ZT4gaXMgXCIgKyBcIm9ubHkgZXZlciByZW5kZXJlZCBpbiByZXNwb25zZSB0byBzb21lIHVzZXIgaW50ZXJhY3Rpb24gb3Igc3RhdGUgY2hhbmdlLlwiKSA6IHZvaWQgMDtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBuYXZpZ2F0ZSh0bywge1xuICAgICAgcmVwbGFjZSxcbiAgICAgIHN0YXRlXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBjaGlsZCByb3V0ZSdzIGVsZW1lbnQsIGlmIHRoZXJlIGlzIG9uZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI291dGxldFxuICovXG5mdW5jdGlvbiBPdXRsZXQocHJvcHMpIHtcbiAgcmV0dXJuIHVzZU91dGxldChwcm9wcy5jb250ZXh0KTtcbn1cblxuLyoqXG4gKiBEZWNsYXJlcyBhbiBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkIGF0IGEgY2VydGFpbiBVUkwgcGF0aC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3JvdXRlXG4gKi9cbmZ1bmN0aW9uIFJvdXRlKF9wcm9wcykge1xuICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIkEgPFJvdXRlPiBpcyBvbmx5IGV2ZXIgdG8gYmUgdXNlZCBhcyB0aGUgY2hpbGQgb2YgPFJvdXRlcz4gZWxlbWVudCwgXCIgKyBcIm5ldmVyIHJlbmRlcmVkIGRpcmVjdGx5LiBQbGVhc2Ugd3JhcCB5b3VyIDxSb3V0ZT4gaW4gYSA8Um91dGVzPi5cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBsb2NhdGlvbiBjb250ZXh0IGZvciB0aGUgcmVzdCBvZiB0aGUgYXBwLlxuICpcbiAqIE5vdGU6IFlvdSB1c3VhbGx5IHdvbid0IHJlbmRlciBhIDxSb3V0ZXI+IGRpcmVjdGx5LiBJbnN0ZWFkLCB5b3UnbGwgcmVuZGVyIGFcbiAqIHJvdXRlciB0aGF0IGlzIG1vcmUgc3BlY2lmaWMgdG8geW91ciBlbnZpcm9ubWVudCBzdWNoIGFzIGEgPEJyb3dzZXJSb3V0ZXI+XG4gKiBpbiB3ZWIgYnJvd3NlcnMgb3IgYSA8U3RhdGljUm91dGVyPiBmb3Igc2VydmVyIHJlbmRlcmluZy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3JvdXRlclxuICovXG5mdW5jdGlvbiBSb3V0ZXIoX3JlZjMpIHtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZTogYmFzZW5hbWVQcm9wID0gXCIvXCIsXG4gICAgY2hpbGRyZW4gPSBudWxsLFxuICAgIGxvY2F0aW9uOiBsb2NhdGlvblByb3AsXG4gICAgbmF2aWdhdGlvblR5cGUgPSBBY3Rpb24uUG9wLFxuICAgIG5hdmlnYXRvcixcbiAgICBzdGF0aWM6IHN0YXRpY1Byb3AgPSBmYWxzZVxuICB9ID0gX3JlZjM7XG4gICEhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiWW91IGNhbm5vdCByZW5kZXIgYSA8Um91dGVyPiBpbnNpZGUgYW5vdGhlciA8Um91dGVyPi5cIiArIFwiIFlvdSBzaG91bGQgbmV2ZXIgaGF2ZSBtb3JlIHRoYW4gb25lIGluIHlvdXIgYXBwLlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGxldCBiYXNlbmFtZSA9IG5vcm1hbGl6ZVBhdGhuYW1lKGJhc2VuYW1lUHJvcCk7XG4gIGxldCBuYXZpZ2F0aW9uQ29udGV4dCA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBiYXNlbmFtZSxcbiAgICBuYXZpZ2F0b3IsXG4gICAgc3RhdGljOiBzdGF0aWNQcm9wXG4gIH0pLCBbYmFzZW5hbWUsIG5hdmlnYXRvciwgc3RhdGljUHJvcF0pO1xuXG4gIGlmICh0eXBlb2YgbG9jYXRpb25Qcm9wID09PSBcInN0cmluZ1wiKSB7XG4gICAgbG9jYXRpb25Qcm9wID0gcGFyc2VQYXRoKGxvY2F0aW9uUHJvcCk7XG4gIH1cblxuICBsZXQge1xuICAgIHBhdGhuYW1lID0gXCIvXCIsXG4gICAgc2VhcmNoID0gXCJcIixcbiAgICBoYXNoID0gXCJcIixcbiAgICBzdGF0ZSA9IG51bGwsXG4gICAga2V5ID0gXCJkZWZhdWx0XCJcbiAgfSA9IGxvY2F0aW9uUHJvcDtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IHRyYWlsaW5nUGF0aG5hbWUgPSBzdHJpcEJhc2VuYW1lKHBhdGhuYW1lLCBiYXNlbmFtZSk7XG5cbiAgICBpZiAodHJhaWxpbmdQYXRobmFtZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aG5hbWU6IHRyYWlsaW5nUGF0aG5hbWUsXG4gICAgICBzZWFyY2gsXG4gICAgICBoYXNoLFxuICAgICAgc3RhdGUsXG4gICAgICBrZXlcbiAgICB9O1xuICB9LCBbYmFzZW5hbWUsIHBhdGhuYW1lLCBzZWFyY2gsIGhhc2gsIHN0YXRlLCBrZXldKTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhsb2NhdGlvbiAhPSBudWxsLCBcIjxSb3V0ZXIgYmFzZW5hbWU9XFxcIlwiICsgYmFzZW5hbWUgKyBcIlxcXCI+IGlzIG5vdCBhYmxlIHRvIG1hdGNoIHRoZSBVUkwgXCIgKyAoXCJcXFwiXCIgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2ggKyBcIlxcXCIgYmVjYXVzZSBpdCBkb2VzIG5vdCBzdGFydCB3aXRoIHRoZSBcIikgKyBcImJhc2VuYW1lLCBzbyB0aGUgPFJvdXRlcj4gd29uJ3QgcmVuZGVyIGFueXRoaW5nLlwiKSA6IHZvaWQgMDtcblxuICBpZiAobG9jYXRpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9jcmVhdGVFbGVtZW50KE5hdmlnYXRpb25Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IG5hdmlnYXRpb25Db250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9jcmVhdGVFbGVtZW50KExvY2F0aW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICB2YWx1ZToge1xuICAgICAgbG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZVxuICAgIH1cbiAgfSkpO1xufVxuXG4vKipcbiAqIEEgY29udGFpbmVyIGZvciBhIG5lc3RlZCB0cmVlIG9mIDxSb3V0ZT4gZWxlbWVudHMgdGhhdCByZW5kZXJzIHRoZSBicmFuY2hcbiAqIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjcm91dGVzXG4gKi9cbmZ1bmN0aW9uIFJvdXRlcyhfcmVmNCkge1xuICBsZXQge1xuICAgIGNoaWxkcmVuLFxuICAgIGxvY2F0aW9uXG4gIH0gPSBfcmVmNDtcbiAgcmV0dXJuIHVzZVJvdXRlcyhjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oY2hpbGRyZW4pLCBsb2NhdGlvbik7XG59IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFVUSUxTXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQ3JlYXRlcyBhIHJvdXRlIGNvbmZpZyBmcm9tIGEgUmVhY3QgXCJjaGlsZHJlblwiIG9iamVjdCwgd2hpY2ggaXMgdXN1YWxseVxuICogZWl0aGVyIGEgYDxSb3V0ZT5gIGVsZW1lbnQgb3IgYW4gYXJyYXkgb2YgdGhlbS4gVXNlZCBpbnRlcm5hbGx5IGJ5XG4gKiBgPFJvdXRlcz5gIHRvIGNyZWF0ZSBhIHJvdXRlIGNvbmZpZyBmcm9tIGl0cyBjaGlsZHJlbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI2NyZWF0ZXJvdXRlc2Zyb21jaGlsZHJlblxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihjaGlsZHJlbikge1xuICBsZXQgcm91dGVzID0gW107XG4gIENoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGVsZW1lbnQgPT4ge1xuICAgIGlmICghIC8qI19fUFVSRV9fKi9pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgLy8gSWdub3JlIG5vbi1lbGVtZW50cy4gVGhpcyBhbGxvd3MgcGVvcGxlIHRvIG1vcmUgZWFzaWx5IGlubGluZVxuICAgICAgLy8gY29uZGl0aW9uYWxzIGluIHRoZWlyIHJvdXRlIGNvbmZpZy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC50eXBlID09PSBGcmFnbWVudCkge1xuICAgICAgLy8gVHJhbnNwYXJlbnRseSBzdXBwb3J0IFJlYWN0LkZyYWdtZW50IGFuZCBpdHMgY2hpbGRyZW4uXG4gICAgICByb3V0ZXMucHVzaC5hcHBseShyb3V0ZXMsIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihlbGVtZW50LnByb3BzLmNoaWxkcmVuKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgIShlbGVtZW50LnR5cGUgPT09IFJvdXRlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJbXCIgKyAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gXCJzdHJpbmdcIiA/IGVsZW1lbnQudHlwZSA6IGVsZW1lbnQudHlwZS5uYW1lKSArIFwiXSBpcyBub3QgYSA8Um91dGU+IGNvbXBvbmVudC4gQWxsIGNvbXBvbmVudCBjaGlsZHJlbiBvZiA8Um91dGVzPiBtdXN0IGJlIGEgPFJvdXRlPiBvciA8UmVhY3QuRnJhZ21lbnQ+XCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBsZXQgcm91dGUgPSB7XG4gICAgICBjYXNlU2Vuc2l0aXZlOiBlbGVtZW50LnByb3BzLmNhc2VTZW5zaXRpdmUsXG4gICAgICBlbGVtZW50OiBlbGVtZW50LnByb3BzLmVsZW1lbnQsXG4gICAgICBpbmRleDogZWxlbWVudC5wcm9wcy5pbmRleCxcbiAgICAgIHBhdGg6IGVsZW1lbnQucHJvcHMucGF0aFxuICAgIH07XG5cbiAgICBpZiAoZWxlbWVudC5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgcm91dGUuY2hpbGRyZW4gPSBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oZWxlbWVudC5wcm9wcy5jaGlsZHJlbik7XG4gICAgfVxuXG4gICAgcm91dGVzLnB1c2gocm91dGUpO1xuICB9KTtcbiAgcmV0dXJuIHJvdXRlcztcbn1cbi8qKlxuICogUmVuZGVycyB0aGUgcmVzdWx0IG9mIGBtYXRjaFJvdXRlcygpYCBpbnRvIGEgUmVhY3QgZWxlbWVudC5cbiAqL1xuXG5mdW5jdGlvbiByZW5kZXJNYXRjaGVzKG1hdGNoZXMpIHtcbiAgcmV0dXJuIF9yZW5kZXJNYXRjaGVzKG1hdGNoZXMpO1xufVxuXG5leHBvcnQgeyBNZW1vcnlSb3V0ZXIsIE5hdmlnYXRlLCBPdXRsZXQsIFJvdXRlLCBSb3V0ZXIsIFJvdXRlcywgTG9jYXRpb25Db250ZXh0IGFzIFVOU0FGRV9Mb2NhdGlvbkNvbnRleHQsIE5hdmlnYXRpb25Db250ZXh0IGFzIFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCwgUm91dGVDb250ZXh0IGFzIFVOU0FGRV9Sb3V0ZUNvbnRleHQsIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiwgZ2VuZXJhdGVQYXRoLCBtYXRjaFBhdGgsIG1hdGNoUm91dGVzLCByZW5kZXJNYXRjaGVzLCByZXNvbHZlUGF0aCwgdXNlSHJlZiwgdXNlSW5Sb3V0ZXJDb250ZXh0LCB1c2VMb2NhdGlvbiwgdXNlTWF0Y2gsIHVzZU5hdmlnYXRlLCB1c2VOYXZpZ2F0aW9uVHlwZSwgdXNlT3V0bGV0LCB1c2VPdXRsZXRDb250ZXh0LCB1c2VQYXJhbXMsIHVzZVJlc29sdmVkUGF0aCwgdXNlUm91dGVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJwYXJzZVBhdGgiLCJjcmVhdGVNZW1vcnlIaXN0b3J5IiwiQWN0aW9uIiwiTmF2aWdhdGlvblR5cGUiLCJjcmVhdGVQYXRoIiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VNZW1vIiwidXNlUmVmIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJjcmVhdGVFbGVtZW50IiwidXNlU3RhdGUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJDaGlsZHJlbiIsImlzVmFsaWRFbGVtZW50IiwiRnJhZ21lbnQiLCJOYXZpZ2F0aW9uQ29udGV4dCIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSIsIkxvY2F0aW9uQ29udGV4dCIsIlJvdXRlQ29udGV4dCIsIm91dGxldCIsIm1hdGNoZXMiLCJpbnZhcmlhbnQiLCJjb25kIiwibWVzc2FnZSIsIkVycm9yIiwid2FybmluZyIsImNvbnNvbGUiLCJ3YXJuIiwiZSIsImFscmVhZHlXYXJuZWQiLCJ3YXJuaW5nT25jZSIsImtleSIsImdlbmVyYXRlUGF0aCIsInBhdGgiLCJwYXJhbXMiLCJyZXBsYWNlIiwiXyIsIm1hdGNoUm91dGVzIiwicm91dGVzIiwibG9jYXRpb25BcmciLCJiYXNlbmFtZSIsImxvY2F0aW9uIiwicGF0aG5hbWUiLCJzdHJpcEJhc2VuYW1lIiwiYnJhbmNoZXMiLCJmbGF0dGVuUm91dGVzIiwicmFua1JvdXRlQnJhbmNoZXMiLCJpIiwibGVuZ3RoIiwibWF0Y2hSb3V0ZUJyYW5jaCIsInBhcmVudHNNZXRhIiwicGFyZW50UGF0aCIsImZvckVhY2giLCJyb3V0ZSIsImluZGV4IiwibWV0YSIsInJlbGF0aXZlUGF0aCIsImNhc2VTZW5zaXRpdmUiLCJjaGlsZHJlbkluZGV4Iiwic3RhcnRzV2l0aCIsInNsaWNlIiwiam9pblBhdGhzIiwicm91dGVzTWV0YSIsImNvbmNhdCIsImNoaWxkcmVuIiwicHVzaCIsInNjb3JlIiwiY29tcHV0ZVNjb3JlIiwic29ydCIsImEiLCJiIiwiY29tcGFyZUluZGV4ZXMiLCJtYXAiLCJwYXJhbVJlIiwiZHluYW1pY1NlZ21lbnRWYWx1ZSIsImluZGV4Um91dGVWYWx1ZSIsImVtcHR5U2VnbWVudFZhbHVlIiwic3RhdGljU2VnbWVudFZhbHVlIiwic3BsYXRQZW5hbHR5IiwiaXNTcGxhdCIsInMiLCJzZWdtZW50cyIsInNwbGl0IiwiaW5pdGlhbFNjb3JlIiwic29tZSIsImZpbHRlciIsInJlZHVjZSIsInNlZ21lbnQiLCJ0ZXN0Iiwic2libGluZ3MiLCJldmVyeSIsIm4iLCJicmFuY2giLCJtYXRjaGVkUGFyYW1zIiwibWF0Y2hlZFBhdGhuYW1lIiwiZW5kIiwicmVtYWluaW5nUGF0aG5hbWUiLCJtYXRjaCIsIm1hdGNoUGF0aCIsIk9iamVjdCIsImFzc2lnbiIsInBhdGhuYW1lQmFzZSIsIm5vcm1hbGl6ZVBhdGhuYW1lIiwicGF0dGVybiIsIm1hdGNoZXIiLCJwYXJhbU5hbWVzIiwiY29tcGlsZVBhdGgiLCJjYXB0dXJlR3JvdXBzIiwibWVtbyIsInBhcmFtTmFtZSIsInNwbGF0VmFsdWUiLCJzYWZlbHlEZWNvZGVVUklDb21wb25lbnQiLCJlbmRzV2l0aCIsInJlZ2V4cFNvdXJjZSIsIlJlZ0V4cCIsInVuZGVmaW5lZCIsInZhbHVlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZXJyb3IiLCJyZXNvbHZlUGF0aCIsInRvIiwiZnJvbVBhdGhuYW1lIiwidG9QYXRobmFtZSIsInNlYXJjaCIsImhhc2giLCJyZXNvbHZlUGF0aG5hbWUiLCJub3JtYWxpemVTZWFyY2giLCJub3JtYWxpemVIYXNoIiwicmVsYXRpdmVTZWdtZW50cyIsInBvcCIsImpvaW4iLCJyZXNvbHZlVG8iLCJ0b0FyZyIsInJvdXRlUGF0aG5hbWVzIiwibG9jYXRpb25QYXRobmFtZSIsImZyb20iLCJyb3V0ZVBhdGhuYW1lSW5kZXgiLCJ0b1NlZ21lbnRzIiwic2hpZnQiLCJnZXRUb1BhdGhuYW1lIiwidG9Mb3dlckNhc2UiLCJuZXh0Q2hhciIsImNoYXJBdCIsInBhdGhzIiwidXNlSHJlZiIsInVzZUluUm91dGVyQ29udGV4dCIsIm5hdmlnYXRvciIsInVzZVJlc29sdmVkUGF0aCIsImpvaW5lZFBhdGhuYW1lIiwiZW5kc1dpdGhTbGFzaCIsImNyZWF0ZUhyZWYiLCJ1c2VMb2NhdGlvbiIsInVzZU5hdmlnYXRpb25UeXBlIiwibmF2aWdhdGlvblR5cGUiLCJ1c2VNYXRjaCIsInVzZU5hdmlnYXRlIiwicm91dGVQYXRobmFtZXNKc29uIiwiSlNPTiIsInN0cmluZ2lmeSIsImFjdGl2ZVJlZiIsImN1cnJlbnQiLCJuYXZpZ2F0ZSIsIm9wdGlvbnMiLCJnbyIsInBhcnNlIiwic3RhdGUiLCJPdXRsZXRDb250ZXh0IiwidXNlT3V0bGV0Q29udGV4dCIsInVzZU91dGxldCIsImNvbnRleHQiLCJQcm92aWRlciIsInVzZVBhcmFtcyIsInJvdXRlTWF0Y2giLCJ1c2VSb3V0ZXMiLCJwYXJlbnRNYXRjaGVzIiwicGFyZW50UGFyYW1zIiwicGFyZW50UGF0aG5hbWUiLCJwYXJlbnRQYXRobmFtZUJhc2UiLCJwYXJlbnRSb3V0ZSIsImxvY2F0aW9uRnJvbUNvbnRleHQiLCJfcGFyc2VkTG9jYXRpb25BcmckcGEiLCJwYXJzZWRMb2NhdGlvbkFyZyIsImVsZW1lbnQiLCJfcmVuZGVyTWF0Y2hlcyIsInJlZHVjZVJpZ2h0IiwiTWVtb3J5Um91dGVyIiwiX3JlZiIsImluaXRpYWxFbnRyaWVzIiwiaW5pdGlhbEluZGV4IiwiaGlzdG9yeVJlZiIsImhpc3RvcnkiLCJzZXRTdGF0ZSIsImFjdGlvbiIsImxpc3RlbiIsIlJvdXRlciIsIk5hdmlnYXRlIiwiX3JlZjIiLCJzdGF0aWMiLCJPdXRsZXQiLCJwcm9wcyIsIlJvdXRlIiwiX3Byb3BzIiwiX3JlZjMiLCJiYXNlbmFtZVByb3AiLCJsb2NhdGlvblByb3AiLCJQb3AiLCJzdGF0aWNQcm9wIiwibmF2aWdhdGlvbkNvbnRleHQiLCJ0cmFpbGluZ1BhdGhuYW1lIiwiUm91dGVzIiwiX3JlZjQiLCJjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4iLCJ0eXBlIiwiYXBwbHkiLCJuYW1lIiwicmVuZGVyTWF0Y2hlcyIsIlVOU0FGRV9Mb2NhdGlvbkNvbnRleHQiLCJVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQiLCJVTlNBRkVfUm91dGVDb250ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/react-router/index.js\n");

/***/ })

};
;